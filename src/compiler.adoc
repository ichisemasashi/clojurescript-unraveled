=== Getting Started with the Compiler

この時点で、あなたはきっと、言語自体についての絶え間ない理論的な説明に非常に飽きていて、何かコードを書いて実行したいと思っていることでしょう。このセクションの目的は、_ClojureScript_ コンパイラを少し実用的に紹介することです。

_ClojureScript_ コンパイラは、数多くのディレクトリや名前空間に分割されたソースコードを、JavaScriptにコンパイルします。今日、JavaScriptには実行可能な環境が非常に多く存在します。- この章では、JavaScriptの使い方を説明します。

この章では、_ClojureScript_ を追加のツールなしで使用する方法を説明します。これは、コンパイラがどのように動作するかを理解し、他のツール( link:http://leiningen.org/[leiningen] + link:https://github.com/emezeske/lein-cljsbuild[cljsbuild] or link:http://boot-clj.com/[boot] など)が利用できない場合に、どのように使用できるかを理解するのに役立ちます。


==== Execution environments

実行環境とは何ですか？実行環境とは、JavaScriptを実行するためのエンジンのことです。例えば、最も一般的な実行環境はブラウザ（Chrome、Firefox、...）で、次に一般的なのは link:https://nodejs.org/[nodejs]です。

他にもRhino (JDK 6+), Nashorn (JDK 8+), QtQuick (QT),...などがありますが、どれも最初の2つとは大きな違いはありません。つまり、現時点での _ClojureScript_ は、ブラウザやnodejsのような環境で実行するコードを箱から出してコンパイルすることができるのです。


==== Download the compiler

ClojureScriptのコンパイルに必要なすべてのツールを入手する最も早い方法は、Clojure CLI Toolsをインストールすることです。

[source, bash]
----
curl -O https://download.clojure.org/install/linux-install-1.10.1.462.sh
chmod +x linux-install-1.10.1.462.sh
sudo ./linux-install-1.10.1.462.sh
----

Linux以外のOSを使用している場合は、https://clojure.org/guides/getting_started のページを参照してください。

_ClojureScript_ はセルフホスト型ですが、本書ではJVM実装を使用しますので、JDK8またはJDK11がインストールされている必要があります。ディストリビューションのデフォルトのパッケージマネージャーを使って入手するか、 link:https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html[Oracle] または link:https://www.azul.com/downloads/zulu-community/[Azul] からダウンロードすることができます。

.Example installing it using a apt in a debian-like distribution
[source, bash]
----
sudo apt-get install openjdk-8-jdk rlwrap
----

==== Compile for Node.js

まずは、*Node.js*（以下、単に「nodejs」）を対象としたコードをコンパイルする実践的な例をご紹介します。この例では、nodejsがインストールされている必要があります。

nodejsをインストールするにはさまざまな方法がありますが、推奨されるのはnvm（「Node.js Version Manager」）を使う方法です。nvmのインストールと使用方法については、 link:https://github.com/creationix/nvm[ホームページ] で説明されています。

nvmをインストールした後は、最新版のnodejsのインストールを行います。

[source, shell]
----
nvm install v10.16.0
nvm alias default v10.16.0
----

このコマンドで、 *nodejs* がシステムにインストールされているかどうかを調べることができます。

[source, shell]
----
$ node --version
v10.16.0
----


===== Create the example application

実践例の最初のステップとして、アプリケーションのディレクトリ構造を作成し、そこにサンプルコードを入力していきます。

まず、"hello world "アプリケーションのディレクトリ・ツリー構造を作成します。

[source, bash]
----
mkdir -p myapp/src/myapp
touch myapp/src/myapp/core.cljs
----

結果として、このようなディレクトリツリーになります。

[source, text]
----
myapp
└── src
    └── myapp
        └── core.cljs
----


次に、先に作成した `myapp/src/myapp/core.cljs` ファイルにサンプルコードを書き込みます。

[source, clojure]
----
(ns myapp.core
  (:require [cljs.nodejs :as nodejs]))

(nodejs/enable-util-print!)

(defn -main
  [& args]
  (println "Hello world!"))

(set! *main-cli-fn* -main)
----

注：ファイル内の宣言された名前空間が、ディレクトリ構造と正確に一致していることが非常に重要です。これは、 _ClojureScript_ がそのソースコードを構成する方法です。

そして最後に、clojureとclojurescriptのバージョンを宣言した`myapp/deps.edn`を作成します。

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}}
 :paths ["src"]}
----


===== Compile the example application

そのソースコードをコンパイルするためには、 _ClojureScript_ コンパイラにソースディレクトリと出力ファイルを伝える簡単なビルドスクリプトが必要です。 _ClojureScript_ には他にもたくさんのオプションがありますが、今のところは無視して構いません。

次のような内容の`myapp/build.clj`ファイルを作ってみましょう。

[source, clojure]
----
(require '[cljs.build.api :as b])

(b/build "src" {:main 'myapp.core
                :output-to "main.js"
                :output-dir "out"
                :target :nodejs
                :verbose true})
----

この例で使用されているコンパイラーオプションについて簡単に説明します。

* `:output-to` パラメータは、コンパイルされたコードの出力先をコンパイラに指示します。ここでは、"main.js "ファイルに出力されます。
* `:main` プロパティは、アプリケーションが実行されたときにエントリポイントとして機能する名前空間をコンパイラに示します。
* `:target` プロパティは、コンパイルしたコードを実行するプラットフォームを示します。ここでは、*nodejs* を使用する予定です。このパラメータを省略すると、ソースはブラウザ環境で実行されるようにコンパイルされます。

コンパイルを実行するには、以下のコマンドを実行するだけです。

[source, bash]
----
cd myapp
clojure build.clj
----

そして、それが終了したら、 *node* を使ってコンパイルされたファイルを実行します。

[source, shell]
----
$ node main.js
Hello world!
----


==== Compile for the Browser

このセクションでは、前のセクションで紹介した「hello world」と同様のアプリケーションを、ブラウザ環境で実行するために作成します。このアプリケーションに最低限必要なのは、JavaScriptを実行できるブラウザだけです。

プロセスはほとんど同じで、ディレクトリ構造も同じです。変わるのは、アプリケーションのエントリーポイントと、ビルドスクリプトだけです。それでは、先ほどの例のディレクトリツリーを別のディレクトリに作り直してみましょう。

[source, bash]
----
mkdir -p mywebapp/src/mywebapp
touch mywebapp/src/mywebapp/core.cljs
----

結果として、このようなディレクトリツリーになります。

[source, text]
----
mywebapp
└── src
    └── mywebapp
        └── core.cljs
----

そして、 `mywebapp/src/mywebapp/core.cljs` ファイルに新しいコンテンツを書き込みます。

[source, clojure]
----
(ns mywebapp.core)

(enable-console-print!)

(println "Hello world!")
----

ブラウザ環境では、アプリケーションの特定のエントリーポイントを必要としないため、エントリーポイントは名前空間全体となります。


===== Compile the example application

ソースコードをコンパイルしてブラウザで正しく動作させるためには、 `mywebapp/build.clj` ファイルを以下の内容で上書きしてください。

[source, clojure]
----
(require '[cljs.build.api :as b])

(b/build "src" {:output-to "main.js"
                :source-map true
                :output-dir "out/"
                :main 'mywebapp.core
                :verbose true
                :optimizations :none})
----

ここでは、使用しているコンパイラオプションについて簡単に説明します。

* `:output-to` パラメータは、コンパイラに対して、コンパイルされたコードの出力先を示します（ここでは "main.js" ファイル）。
* `:main` プロパティは、アプリケーションが実行されたときにエントリポイントとして機能する名前空間をコンパイラに示します。
* `:source-map` プロパティは、ソースマップの出力先を示します。(ソースマップはClojureScriptのソースと生成されたJavaScriptを接続し、エラーメッセージが元のソースを指し示すことができるようにします。)
* `:output-dir` は、コンパイル時に使用するすべてのファイルソースの出力先ディレクトリを示します。これはソースマップを自分のソースだけでなく、残りのコードで正しく動作させるためのものです。
* `:optimizations` は、コンパイル時の最適化を示します。このオプションにはさまざまな値がありますが、これについては後のセクションで詳しく説明します。

コンパイルを実行するには、以下のコマンドを実行するだけです。

[source, bash]
----
cd mywebapp;
clojure build.clj
----

このプロセスには時間がかかりますので、心配せずに少しだけ待ってください。ClojureコンパイラによるJVMブートストラップは若干遅いです。次のセクションでは、この遅いプロセスを常に開始したり停止したりするのを避けるために、ウォッチ・プロセスを開始する方法を説明します。

コンパイルを待つ間に、サンプルアプリをブラウザで簡単に実行できるように、ダミーのHTMLファイルを作成しましょう。以下の内容の _index.html_ ファイルを作成し、メインの _mywebapp_ ディレクトリに置きます。

[source, html]
----
<!DOCTYPE html>
<html>
  <header>
    <meta charset="utf-8" />
    <title>Hello World from ClojureScript</title>
  </header>
  <body>
    <script src="main.js"></script>
  </body>
</html>
----

コンパイルが終わり、基本的なHTMLファイルができあがったら、好きなブラウザで開いて、開発ツールのコンソールを見てみましょう。"Hello world!"というメッセージが表示されるはずです。


==== Watch process

_ClojureScript_ コンパイラの起動時間が遅いことにすでにお気づきかもしれません。この問題を解決するために、 _ClojureScript_ スタンドアロンコンパイラには、ソースコードの変更を監視し、変更されたファイルがディスクに書き込まれるとすぐに再コンパイルするツールが付属しています。

それでは、build.cljスクリプトを、引数を受け取ってさまざまなタスクを実行できるものに変換してみましょう。次のような内容の `tools.clj` スクリプトファイルを作ってみましょう。

[source, clojure]
----
(require '[cljs.build.api :as b])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-> task methods (dissoc :default) keys sort)
        interposed (->> all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(def build-opts
  {:output-to "main.js"
   :source-map true
   :output-dir "out/"
   :main 'mywebapp.core
   :verbose true
   :optimizations :none})

(defmethod task "build"
  [args]
  (b/build "src" build-opts))

(defmethod task "watch"
  [args]
  (b/watch"src" build-opts))

(task *command-line-args*)
----

これで、以下のコマンドで監視プロセスを開始できます。

[source, bash]
----
clojure tools.clj watch
----

名前空間 `mywebapp.core` に戻り、表示文字列を `"Hello World, Again!"` に変更します。 すると、ファイル `src/mywebapp/core.cljs` がすぐに再コンパイルされ、ブラウザで `index.html` をリロードすると、開発者コンソールに新しいテキストが表示されることがわかります。

また、次のようにしてシンプルなビルドを開始することもできます。

[source, bash]
----
clojure tools.clj build
----

最後に、 `build.clj` スクリプトをパラメータなしで実行すると、利用可能な「タスク」を示すヘルプメッセージが表示されます。

[source, bash]
----
$ clojure tools.clj
Unknown or missing task. Choose one of: build, watch
----


==== Optimization levels

_ClojureScript_コンパイラには、さまざまな最適化のレベルがあります。舞台裏では、これらのコンパイルレベルは Google Closure Compiler から来ています。

コンパイルプロセスの簡単な概要は以下の通りです。

1. リーダーはコードを読み、何らかの分析を行います。この段階でコンパイラはいくつかの警告を出すかもしれません。
2. 次に、 _ClojureScript_ コンパイラがJavaScriptのコードを出力します。その結果、各ClojureScript入力ファイルに対して、1つのJavaScript出力ファイルが作成されます。
3. 生成されたJavaScriptファイルは、Google Closure Compilerに渡され、最適化レベルやその他のオプション（ソースマップ、出力ディレクトリ、出力先など）に応じて、最終的な出力ファイルが生成されます。

最終的な出力フォーマットは、選択した最適化レベルによって異なります。


===== none

この最適化レベルでは、生成されたJavaScriptは、コードに追加の変換を加えることなく、名前空間ごとに別々の出力ファイルに書き込まれます。


===== whitespace

この最適化レベルでは、生成されたJavaScriptファイルが、依存関係のある順に1つの出力ファイルに連結されます。 改行やその他のホワイトスペースは削除されます。

これにより、コンパイル速度が多少低下します。しかし、ひどく遅いわけではないので、小～中規模のアプリケーションであれば十分に使用可能です。

===== simple

シンプルなコンパイルレベルでは、 `whitespace` 最適化レベルでの作業をベースに、ローカル変数や関数のパラメータの名前を短く変更するなど、式や関数内での最適化を追加で行います。

`:simple` の最適化によるコンパイルでは、構文的に有効な JavaScript の機能が常に維持されるので、コンパイルされた _ClojureScript_ と他の JavaScript との相互作用に支障をきたすことはありません。


===== advanced

アドバンスド・コンパイル・レベルは、 `simple` な最適化レベルをベースに、より積極的な最適化とデッドコードの排除を行います。これにより その結果、出力ファイルが大幅に小さくなります。

`:advanced` の最適化は、Google Closure Compilerのルールに従った厳格なJavaScriptのサブセットに対してのみ機能します。  _ClojureScript_ はこの厳密なサブセット内では有効なJavaScriptを生成しますが、サードパーティのJavaScriptコードとやり取りする場合には、すべてを期待通りに動作させるためにいくつかの追加作業が必要になります。

このサードパーティ製の JavaScript ライブラリとの連携については、後のセクションで説明します。


=== Working with the REPL

////
TODO: maybe it would be interesting to take some ideas from
http://www.alexeberts.com/exploring-the-clojurescript-repl/
////


==== Introduction

ClojureScriptで何かを試したいときには、その都度ソースファイルを作成してコンパイルすることもできますが、REPLを使った方が簡単です。REPLは以下の略です。

* Read - キーボードから入力を得る
* 入力を評価(Evaluate)する
* 結果を表示(Print)する
* 次の入力を得るためにループバック(Loop back)する

つまり、REPLを使えば、ClojureScriptのコンセプトを試して、すぐにフィードバックを得ることができます。

_ClojureScript_ には、異なる実行環境でREPLを実行するためのサポートが付属しており、それぞれに長所と短所があります。例えば、nodejsでREPLを実行することができますが、その環境ではDOMにアクセスすることができません。 どのREPL環境が最適なのかは、特定のニーズや要求に依存します。


==== Nashorn REPL

Nashorn REPLは、特別なものを必要としないため、最も簡単で、おそらく最も苦痛のないREPL環境です。

まず、新しいディレクトリ（ここでは `repl_playground/tools.clj` ）に、`tools.clj` という repl playground 用の新しいスクリプトファイルを作成しましょう。

[source, clojure]
----
(require '[cljs.repl :as repl])
(require '[cljs.repl.nashorn :as nashorn])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-> task methods (dissoc :default) keys sort)
        interposed (->> all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(defmethod task "repl:nashorn"
  [args]
  (repl/repl (nashorn/repl-env)
             :output-dir "out/nashorn"
             :cache-analysis true))

(task *command-line-args*)
----

以下の内容の `repl_playground/deps.edn` ファイルを作成します（これまでの例と同じです）。

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}}
 :paths ["src"]}
----

そして、これでREPLを実行することができます。

[source, bash]
----
$ clj tools.clj repl:nashorn
ClojureScript 1.10.520
cljs.user=> (prn "Hello world")
"Hello world"
nil
----

この例では、 `clojure` の代わりに `clj` コマンドを使用していることにお気づきでしょうか。この2つのコマンドは実質的に同じですが、主な違いは `clj` が `rlwrap` でラップされた `clojure` コマンドを実行することです。 `rrlwrap` ツールは、履歴やコードナビゲーション、その他のシェルのような機能を可能にする「readline」機能を提供し、REPLでの経験をより快適なものにしてくれます。

まだインストールしていない場合は、 `sudo apt install -y rlwrap` でインストールできます。

注: これは基本的なREPLです。次の章では、コードハイライト、コードコンプリート、マルチラインエディションなど、より高度なREPLを体験する方法を説明します。


==== Node.js REPL

このREPLを使うには、もちろんnodejsがシステムにインストールされている必要があります。

すでに外部依存のないnashorn REPLがあるのに、なぜnodejs REPLが必要なのかと思われるかもしれません。その答えはとても簡単で、nodejsはバックエンドで最も使われているJavaScript実行環境であり、その周りには多くのコミュニティパッケージが構築されているからです。

良いニュースは、nodejsのREPLを始めるのは、一度システムにインストールしてしまえばとても簡単だということです。以下の内容を `tools.clj` スクリプトに追加してください。

[source, clojure]
----
(require '[cljs.repl.node :as node])

(defmethod task "node:repl"
  [args]
  (repl/repl (node/repl-env)
             :output-dir "out/nodejs"
             :cache-analysis true))
----

そして、REPLを起動します。

[source,bash]
----
$ clj tools.clj repl:node
ClojureScript 1.10.520
cljs.user=> (prn "Hello world")
"Hello world"
nil
----


==== Browser REPL

このREPLは、立ち上げるのに最も手間がかかる。これは、実行環境にブラウザを使用していることと、追加の要件があるためです。

まずは、 `tools.clj` スクリプトファイルに以下の内容を追加してみましょう。

[source, clojure]
----
(require '[cljs.build.api :as b])
(require '[cljs.repl.browser :as browser])

(defmethod task "repl:browser"
  [args]
  (println "Building...")
  (b/build "src"
           {:output-to "out/browser/main.js"
            :output-dir "out/browser"
            :source-map true
            :main 'myapp.core
            :optimizations :none})

  (println "Launching REPL...")
  (repl/repl (browser/repl-env :port 9001)
             :output-dir "out/browser"))
----

これまでの例との主な違いは、ブラウザREPLでは、REPLを動作させる前に、ブラウザで何らかのコードを実行する必要があることです。そのためには、これまでのセクションで使用してきたものとよく似たアプリケーション構造を再作成します。

[source, bash]
----
mkdir -p src/myapp
touch src/myapp/core.cljs
----

そして、 `src/myapp/core.cljs` ファイルに新しいコンテンツを書き込みます。

[source, clojure]
----
(ns myapp.core
 (:require [clojure.browser.repl :as repl]))

(defonce conn
  (repl/connect "http://localhost:9001/repl"))

(enable-console-print!)

(println "Hello, world!")
----

そして最後に、REPLのブラウザ側のコードを実行するためのエントリーポイントとして使用される、欠落している _index.html_ ファイルを作成します。

[source, html]
----
<!DOCTYPE html>
<html>
  <header>
    <meta charset="utf-8" />
    <title>Hello World from ClojureScript</title>
  </header>
  <body>
    <script src="out/browser/main.js"></script>
  </body>
</html>
----

さて、セットアップが大変でしたね。でも、実際に動いているところを見れば、その価値は十分にあると思います。そのためには、これまでの例と同じように、 `tools.clj` を実行してください。

[source, bash]
----
$ clj tools.clj repl:browser
Building...
Launching REPL...
ClojureScript 1.10.520
cljs.user=>
----

そして最後に、お気に入りのブラウザを開き、http://localhost:9001/。ページが読み込まれたら（ページは真っ白になります）、REPLを実行したコンソールに切り替えると、起動していることが確認できます。

[source, bash]
----
[...]
To quit, type: :cljs/quit
cljs.user=> (+ 14 28)
42
----

ブラウザREPLの大きな利点の一つは、ブラウザ環境のすべてにアクセスできることです。例えば、REPLで `(js/alert "hello world")` と入力します。これにより、ブラウザにアラートボックスが表示されます。いいですねー。

注：これは、ClojureScriptコンパイラに組み込まれたREPL機能の使い方のプレビューに過ぎません。コードハイライト、コードコンプリート、マルチラインエディション（Web開発の場合は、コードのホットリロードも可能）など、よりユーザーや開発者に優しい複製環境がありますので、次の章で説明します。


==== Rebel Readline (REPL library)

これは、Clojure(Script)の組み込みREPLにさらに高度な機能を追加するライブラリで、コードハイライト、コードコンプリート、マルチラインエディションを可能にします。

早速、`deps.edn`ファイルに反乱軍(rebel)の依存関係を追加してみましょう。

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}
        com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}
        com.bhauman/rebel-readline {:mvn/version "0.1.4"}}
 :paths ["src"]}
----

そして、以下のコードを `tools.clj` スクリプトファイルに追加します。

[source, clojure]
----
(require '[rebel-readline.core]
         '[rebel-readline.clojure.main]
         '[rebel-readline.clojure.line-reader]
         '[rebel-readline.cljs.service.local]
         '[rebel-readline.cljs.repl])

(defmethod task "repl:rebel:node"
  [args]
  (rebel-readline.core/with-line-reader
    (rebel-readline.clojure.line-reader/create
     (rebel-readline.cljs.service.local/create))
    (repl/repl (node/repl-env)
               :prompt (fn [])
               :read (rebel-readline.cljs.repl/create-repl-read)
               :output-dir "out/nodejs"
               :cache-analysis true)))
----

そして、REPLを起動します。

[source, bash]
----
$ clojure tools.clj repl:rebel:node
ClojureScript 1.10.520
cljs.user=> (println)
cljs.core/println: ([& objs])
----

REPLで書いている間に、実行したい関数記号が自動的に提案され、表示されることがわかります。

rebel-readlineの全機能に関する詳細は、https://github.com/bhauman/rebel-readline でご覧いただけます。



=== The Closure Library

Google Closure Libraryは、Googleが開発したjavascriptライブラリです。モジュール式のアーキテクチャを採用し、DOM操作やイベント、ajaxやJSONなどのクロスブラウザ機能を提供しています。

Google Closure Libraryは、Closure Compiler（ _ClojureScript_ コンパイラが内部的に使用しているもの）を活用するために特別に書かれています。

_ClojureScript_ はGoogle Closure CompilerとClosure Libraryをベースに作られています。実際、 _ClojureScript_ の名前空間はClosureのモジュールです。これは、Closure Libraryと非常に簡単にやりとりできることを意味しています。

[source, clojure]
----
(ns yourapp.core
  (:require [goog.dom :as dom]))

(def element (dom/getElement "body"))
----

このコードスニペットは、Closureライブラリの *dom* モジュールをインポートし、そのモジュールで宣言された関数を使用する方法を示しています。

さらに，closureライブラリは，クラスやオブジェクトのように振る舞う「特別な」モジュールを公開しています。これらの機能を使うには、 `(ns ...)` 形式の `:import` ディレクティブを使う必要があります。

[source, clojure]
----
(ns yourapp.core
  (:import goog.History))

(def instance (History.))
----

_Clojure_ のプログラムでは、ホスト(Java)のインターロップとして、Javaのクラスをインポートするために `:import` ディレクティブを使用します。 しかし、 _ClojureScript_ で型(クラス)を定義する場合には、`:import` ディレクティブではなく、標準の `:require` ディレクティブを使用する必要があります。

クロージャライブラリのすべての名前空間のリファレンスは、こちらをご覧ください。
http://google.github.io/closure-library/api/


=== Dependency management

これまでは、内蔵されている _Clojure(Script)_ ツールチェーンを使って、ソースファイルをJavaScriptにコンパイルしてきました。ここからは、外部やサードパーティの依存関係をどのように管理するかを理解する時期になります。


==== First project

あるツールがどのように機能するかを示す最良の方法は、そのツールを使ってトイプロジェクトを作成することです。今回は、ある年がうるう年かどうかを判断する小さなアプリケーションを作成します。

まず、プロジェクトのレイアウトを作成しましょう。

[source, bash]
----
mkdir -p leapyears/src/leapyears
mkdir -p leapyears/target/public
touch leapyears/target/public/index.html
touch leapyears/src/leapyears/core.cljs
touch leapyears/tools.cljs
touch leapyears/deps.edn
----

このプロジェクトは以下のような構成になっています。

----
leapyears
├── deps.edn
├── src
│   └── leapyears
│       └── core.cljs
├── target
│   └── public
│       └── index.html
└── tools.clj
----

`deps.edn` ファイルには、アプリケーションのビルドや実行に必要な、すべての *パッケージ化された* 依存関係の情報が含まれています。パッケージ化された依存関係とは、jarファイルとしてパッケージ化され、clojars/mavenリポジトリにアップロードされたライブラリのことです。

[注釈]
====
しかし、ClojureScriptは様々な方法で外部コードを消費することができます。

- グーグルclosureライブラリ・モジュール
- グローバル エクスポート モジュール
- es6/commonjsモジュール(実験的)

これについては、次のセクションで説明します。
====

まずは、シンプルな`deps.edn`ファイルを作ってみましょう。

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}
        com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}
        com.bhauman/rebel-readline {:mvn/version "0.1.4"}}
 :paths ["src" "target"]}
----

そして、シンプルなビルドスクリプト（ `tools.clj` ファイル）。

[source, clojure]
----
(require '[cljs.build.api :as b])
(require '[cljs.repl :as repl])
(require '[cljs.repl.node :as node])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-> task methods (dissoc :default) keys sort)
        interposed (->> all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(def build-opts
  {:output-to "target/public/js/leapyears.js"
   :source-map true
   :output-dir "target/public/js/leapyears"
   :main 'leapyears.core
   :verbose true
   :optimizations :none})

(defmethod task "repl"
  [args]
  (repl/repl (node/repl-env)
             :output-dir "target/nodejs"
             :cache-analysis true))

(defmethod task "build"
  [args]
  (b/build "src" build-opts))

(defmethod task "watch"
  [args]
  (b/watch "src" build-opts))

(task *command-line-args*)
----

次に、 `target/public/index.html` ファイルに以下の内容を記述します。

[source, html]
----
<!DOCTYPE html>
<html>
  <head>
    <title>leapyears</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  </head>
  <body>
    <section class="viewport">
      <div id="result">
        ----
      </div>

      <form action="" method="">
        <label for="year">Input a year</label>
        <input id="year" name="year" />
      </form>
    </section>

    <script src="./js/leapyears.js" type="text/javascript"></script>
  </body>
</html>
----

次のステップでは、フォームをインタラクティブにするためのコードを追加します。以下のコードを `src/leapyears/core.cljs` に記述してください。

[source, clojure]
----
(ns leapyears.core
  (:require [goog.dom :as dom]
            [goog.events :as events]
            [cljs.reader :refer (read-string)]))

(enable-console-print!)

(def input (dom/getElement "year"))
(def result (dom/getElement "result"))

(defn leap?
  [year]
  (or (zero? (js-mod year 400))
      (and (pos? (js-mod year 100))
           (zero? (js-mod year 4)))))

(defn on-change
  [event]
  (let [target (.-target event)
        value (read-string (.-value target))]
    (if (leap? value)
      (set! (.-innerHTML result) "YES")
      (set! (.-innerHTML result) "NO"))))

(events/listen input "keyup" on-change)
----

これで、プロジェクトをコンパイルすることができます。

[source, bash]
----
clojure tools.clj watch
----

最後に、 `target/public/index.html` ファイルをブラウザで開きます。テキストボックスに年号を入力すると、その年がうるう年であるかどうかが表示されます。


==== Adding native dependencies

これまでは、ClojureScriptランタイムに含まれるバッテリーのみを使用していましたが、ネイティブな依存関係を含むプロジェクトを改善しましょう。この例では、 link:https://github.com/funcool/cuerdas[Cuerdas]  (Clojure(Script)専用に構築された文字列操作ライブラリ)を使用します。

`funcool/cuerdas {:mvn/version "2.2.0"}` を `deps.edn` ファイル内の `:deps` セクションに追加します。また、`leapyears/core.cljs` ファイルにも対応する修正を加えます。

[source, clojure]
----
(ns leapyears.core
  (:require [goog.dom :as dom]
            [goog.events :as events]
            [cuerdas.core :as str]
            [cljs.reader :refer (read-string)]))

;; [...]

(defn on-change
  [event]
  (let [target (.-target event)
        value (read-string (.-value target))]

    (if (str/blank? value)
      (set! (.-innerHTML result) "---")
      (if (leap? value)
        (set! (.-innerHTML result) "YES")
        (set! (.-innerHTML result) "NO")))))
----

これで、buildコマンドやwatchコマンドを実行すると、新しく宣言された依存関係がダウンロードされ、この依存関係が含まれた状態でアプリケーションがコンパイルされるようになります。

Clojureのパッケージは、しばしば link:http://clojars.org[Clojars] で公開されています。また、 link:https://github.com/clojure/clojurescript/wiki#libraries[ClojureScript Wiki] で多くのサードパーティライブラリを見つけることができます。


==== External dependencies

いくつかの状況では、 _ClojureScript_ には存在しないが、javascriptにはすでに実装されているライブラリが必要で、それをプロジェクトで使用したいと思うことがあるかもしれません。

これを行うには、主にインクルードしたいライブラリに応じて多くの方法があります。そのようなライブラリの多くはパッケージ化され、clojarsにアップロードされていますので、ネイティブの依存関係と同じように `deps.edn` で宣言することができます（使い方にはいくつかの特徴がありますが、以下を参照してください）。


==== Closure compatible module

google closure module systemと互換性があるように書かれたライブラリを持っていて、それをプロジェクトに含めたい場合は、ソースをクラスパスに入れ（leapyearsプロジェクトの `src` または `vendor` ディレクトリ内）、他のclojure名前空間と同様にアクセスします。

google closure moduleは直接互換性があるので、追加のステップなしに、clojureのコードとgoogle closure module systemを使って書かれたjavascriptのコードを混ぜることができるからです。

leapyearsプロジェクトを参考にして、google closure module形式を使ったjavascriptで、 `leap?` 関数を実装してみましょう。ディレクトリ構造の作成を開始します。

[source, bash]
----
touch src/leapyears/util.js
----

そして、closureモジュール形式で実装を追加します。

.src/leapyears/util.js
[source, js]
----
goog.provide("leapyears.util");

goog.scope(function() {
  var module = leapyears.util;

  module.isLeap = function(val) {
    return (0 === (val % 400)) || (((val % 100) > 0) && (0 === (val % 4)));
  };
});
----

これで repl を開くと、名前空間をインポートして、`isLeap` 関数を使うことができます。

[source, clojure]
----
(require '[leapyears.util :as util])

(util/isLeap 2112)
;; => true

(util/isLeap 211)
;; => false
----

注: プロジェクトのルートで `clj tools.clj repl` を実行するだけで、nodejs repl を開くことができます。

注: これは、パフォーマンスに敏感なロジックをjavascriptで直接実装し、それをClojureScriptに簡単にエクスポートするために、多くのプロジェクトで使用されている方法です。


==== Global Export

これは、ClojureScriptから外部のjavascriptライブラリを消費するための、最も拡張された、最も信頼できる方法であり、多くの機能を備えています。

これで遊んでみましょう。まず、Commonjsモジュール形式のシンプルなファイルを作成します(google closureモジュールを使った前の例とよく似ています)。

javascriptライブラリをインクルードする最も早い方法は、 link:http://cljsjs.github.io/[CLJSJS] で利用できるかどうかを調べることです。利用可能であれば、その依存関係を `deps.edn` ファイルに含めて使用します。

このライブラリには、2つの使用方法があります。

まず、`deps.edn` ファイルに `moment` の依存関係を追加します。

[source, clojure]
----
cljsjs/moment {:mvn/version "2.24.0-0"}
----

その後、replを開いて以下を試してみてください。

.using the `js/` special namespace
[source, clojure]
----
(require '[cljsjs.moment]) ;; just require, no alias

(.format (js/moment) "LLLL")
;; => "Monday, July 15, 2019 5:32 PM"
----

.using the alias
[source, clojure]
----
(require '[moment :as m])

(.format (m) "LLLL")
;; => "Monday, July 15, 2019 5:33 PM"
----

舞台裏では、パッケージはClojureScriptのコンパイラ機能 link:https://clojurescript.org/reference/compiler-options#foreign-libs[descripted here] を使って、コンパイラに使用するファイルやグローバルエクスポートに関する十分な情報を提供しています。

ですから、もしcljsjsにライブラリが見つからなくても、同じ機能を使ってそれをインクルードすることができます。例えば、momentがcljsjsにはなく、私たちのプロジェクトに必要だと仮定しましょう。

外部の依存関係をインクルードするためには、 `:foreign-libs` と `:externs` のパラメターをClojureScriptコンパイラに渡す必要がありますが、2つの方法があります。

- それらを `build` または `repl` 関数に渡す。
- クラスパスのルートにある `deps.cljs` ファイルの中に入れます。

`deps.cljs` では、ファイルをローカルディレクトリに置く必要がありますが、最初の方法では、外部URLを直接指定することができます。今回の例では、第一のアプローチを使用します。

変更を適用した `deps.edn` ファイルの外観は次のとおりです。

[source, clojure]
----
;; [...]

(def foreign-libs
  [{:file "https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.js"
    :file-min "https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"
    :provides ["vendor.moment"]}])


(def build-opts
  {:output-to "target/public/js/leapyears.js"
   :source-map true
   :output-dir "target/public/js/leapyears"
   :main 'leapyears.core
   :verbose true
   :optimizations :none
   :foreign-libs foreign-libs})

(defmethod task "repl"
  [args]
  (repl/repl (node/repl-env)
             :foreign-libs foreign-libs
             :output-dir "target/node"
             :cache-analysis true))

;; [...]
----

replを実行すると、cljsjsパッケージを使用している場合と同じように、 `vendor.moment` をインポートできるようになります。

最後に、 `:externs` というオプションがありますが、これはプロダクションビルドの時にのみ必要になります。externsファイルは、プレーンなjavascriptファイルで構成されており、インクルードされた外部のライブラリのパブリックAPIを宣言し、google closureコンパイラが理解できるようにします。


moment externsは link:https://github.com/cljsjs/packages/blob/master/moment/resources/cljsjs/common/moment.ext.js[こちら] で公開されています。使用したいライブラリをインクルードして、高度な最適化をしてアプリをコンパイルしたい場合は、プロジェクトにmoment.ext.jsのようなファイルをインクルードして、ClojureScriptコンパイラに `:externs` オプションで参照させる必要があります。

詳しい情報は、 https://clojurescript.org/reference/compiler-options#externs[on clojurescript.org] をご覧ください。


==== ES6/CommonJS modules

Google Closure Compilerには、異なるモジュールタイプ(commonjsやES)をGoogle Closureモジュールタイプに変換することができる高度な機能があります。しかし、この機能はまだ実験的なものです。単純なモジュールでは動作しますが、複雑なモジュール（多くのサブモジュールやディレクトリ）では、まだ正しく準拠していません。

いずれにしても、この機能を試してみてください。詳しいドキュメントは link:https://clojurescript.org/reference/javascript-module-support[clojurescript.org] でご覧いただけます。

ES6やCommonJSモジュールを使用するための最良の方法は、 _rollup_ や _webpack_ のようなjavascript bundlerを組み合わせて、外部依存性を持つ単一のビルドを生成し、次にClojureScriptでそれを使用するために *global exports* メソッドを使用することです。この例は、 link:https://clojurescript.org/guides/webpack[on clojurescript.org] で説明されています。


=== Interactive development with Figwheel

そして最後に、完全にインタラクティブな、REPLベースの、ホットリロード可能な開発環境を実現する *figwheel* を紹介します。

以下の例では、leapyearsプロジェクトの構造を再利用しています。

注：ここではfigwheelをWebアプリケーションに使用していますが、実行環境としてnodejsをターゲットにしたアプリケーションでも同じように動作します。

最初のステップとして、 *figwheel* の依存関係を `deps.edn` ファイルに追加する必要があります。

[source, clojure]
----
com.bhauman/figwheel-main {:mvn/version "0.2.1"}
----

そして、 `tools.clj` スクリプトに新しいタスクを追加します。

[source, clojure]
----
(def figwheel-opts
  {:open-url false
   :load-warninged-code true
   :auto-testing false
   :ring-server-options {:port 3448 :host "0.0.0.0"}
   :watch-dirs ["src"]})

(defmethod task "figwheel"
  [args]
  (figwheel/start figwheel-opts {:id "main" :options build-opts}))
----


そして、 `clojure tools.clj fighweel` を実行します。これでfigwheelプロセスが起動し、自動的にhttpサーバーを立ち上げて、 `target/public/` ディレクトリと `index.html` ファイルへのインデックスを提供するようになります。

コードを更新すると、そのコードが自動的にブラウザに読み込まれ、 *ページを再読み込みする必要はありません* 。

詳しくは、 link:https://figwheel.org/[figwheel.org] をご覧ください。


=== Unit testing

ご想像のとおり、 _ClojureScript_ のテストは、Clojure、Java、Python、JavaScriptなどの他の言語で広く使われているのと同じコンセプトで構成されています。

言語を問わず、ユニットテストの主な目的は、いくつかのテストケースを実行し、テスト対象のコードが期待通りに動作し、予期せぬ例外を発生させずに戻ってくることを検証することです。

_ClojureScript_ のデータ構造が不変であることは、プログラムがエラーを起こしにくくするのに役立ち、テストを少しだけ容易にします。 _ClojureScript_ のもう一つの利点は、複雑なオブジェクトではなく、普通のデータを使う傾向があることです。そのため、テスト用の「モック」オブジェクトの構築が非常に簡単です。


==== First steps

「公式」 _ClojureScript_ テストフレームワークは、「cljs.test」名前空間にあります。これは非常にシンプルなライブラリですが、私たちの目的には十分すぎるほどのものです。

link:https://github.com/clojure/test.check[test.check] のように、追加の機能を提供したり、直接異なるアプローチでテストを行うライブラリもあります。しかし、ここではそれらを取り上げません。

ここでは、 `leapyears` プロジェクトの構造を再利用し、そこにテストを追加していきます。テスト関連のファイルやディレクトリを作成しましょう。

[source, bash]
----
mkdir -p test/leapyears/test
touch test/leapyears/test/main.cljs
----

また、 `tools.clj` ファイルに、テストの構築、監視、実行のための新しいタスクを作成する必要があります。

[source, clojure]
----
(require '[clojure.java.shell :as shell])

;; [...]

(defmethod task "build:tests"
  [args]
  (b/build (b/inputs "src" "vendor" "test")
           (assoc build-opts
                  :main 'leapyears.test.main
                  :output-to "out/tests.js"
                  :output-dir "out/tests"
                  :target :nodejs)))

(defmethod task "watch:test"
  [args]
  (letfn [(run-tests []
            (let [{:keys [out err]} (shell/sh "node" "out/tests.js")]
              (println out err)))]
    (println "Start watch loop...")
    (try
      (b/watch (b/inputs "src", "test")
               (assoc build-opts
                      :main 'leapyears.test.main
                      :watch-fn run-tests
                      :output-to "out/tests.js"
                      :output-dir "out/tests"
                      :target :nodejs))

      (catch Exception e
        (println "Error on running tests:" e)
        ;; (Thread/sleep 2000)
        (task args)))))
----

次に、 `test/leapyears/test/main.cljs` ファイルにテストコードを入れます。

[source, clojure]
----
(ns leapyears.test.main
  (:require [cljs.test :as t]))

(enable-console-print!)

(t/deftest my-first-test
  (t/is (= 1 2)))

(set! *main-cli-fn* #(t/run-tests))

;; この拡張機能は、テストが成功したかどうかに応じてリターンコードを正しく設定するために必要です。
(defmethod t/report [:cljs.test/default :end-run-tests]
  [m]
  (if (t/successful? m)
    (set! (.-exitCode js/process) 0)
    (set! (.-exitCode js/process) 1)))
----

そのコードスニペットの関連部分は

[source, clojure]
----
(t/deftest my-first-test
  (t/is (= 1 2)))
----

`deftest` マクロは、テストを定義するための基本的なプリミティブです。最初のパラメータとして名前を受け取り、続いて `is` マクロを使用した 1 つまたは複数のアサーションを受け取ります。この例では、 `(= 1 2)`  が真であることを主張しています。

これを実行してみましょう。

[source,bash]
----
$ clojure tools build:tests
$ node out/tests.js
Testing mytestingapp.core-tests

FAIL in (my-first-test) (cljs/test.js:374:14)
expected: (= 1 2)
  actual: (not (= 1 2))

Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
----

期待していた assert の失敗がコンソールにうまく表示されているのがわかります。テストを修正するには、 `=` を `not=` に変更して、再度ファイルを実行してください。

[source, bash]
----
$ clojure tools build:tests
$ node out/mytestingapp.js

Testing mytestingapp.core-tests

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.
----

この種のアサーションをテストするのは結構ですが、あまり役に立ちません。それでは、いくつかのアプリケーションコードをテストしてみましょう。ここでは、ある年がうるう年であるかどうかをチェックする関数を使用します。

[source, clojure]
----
(ns leapyears.test.main
  (:require [cljs.test :as t]
            [leapyears.vendor.util-closure :as util]))

;; [...]

(t/deftest my-second-test
  (t/is (util/isLeap 1980))
  (t/is (not (util/isLeap 1981))))

;; [...]
----

コンパイルしたファイルを再度実行すると、2つのテストが実行されていることがわかります。 最初のテストは以前と同様に通過し、2つの新しい閏年のテストも通過しました。


==== Async Testing

_ClojureScript_ の特殊性の一つに、非同期、シングルスレッドの実行環境で動作することがあり、これには課題があります。

非同期実行環境では、非同期関数をテストできるようにしなければなりません。そのために、 _ClojureScript_ テストライブラリは  `async`  マクロを提供しており、非同期コードでうまく動作するテストを作成することができます。

まず、非同期的に動作する関数を書く必要があります。この目的のために、 `async-leap?` という述語を作ります。この述語は同じ操作を行いますが、コールバックを使って非同期に結果を返します。

[source, clojure]
----
(defn async-leap?
  [year callback]
  (js/setImmediate #(callback (util/isLeap year))))
----

JavaScriptの関数 `setImmediate` を使って非同期タスクをエミュレートし、その述語の結果でコールバックを実行しています。

これをテストするには、先に述べた `async` マクロを使ってテストケースを書く必要があります。

[source, clojure]
----
(t/deftest my-async-test
  (t/async done
    (async-leap? 1980 (fn [result]
                        (t/is (true? result))
                              (done))))) depending if the test passes or not.
----

`async` マクロで公開される `done` 関数は、非同期操作が終了し、すべてのアサーションが実行された後に呼び出されるべきです。

`done` 関数は一度だけ実行することが非常に重要です。この関数を省略したり、2回実行したりすると、おかしな動作を引き起こす可能性があるので、避けるべきです。
