=== Getting Started with the Compiler

At this point, you are surely very bored with the constant theoretical explanations about the language itself and will want to write and execute some code. The goal of this section is to provide a little practical introduction to the _ClojureScript_ compiler.

The _ClojureScript_ compiler takes the source code that has been split over numerous directories and namespaces and compiles it down to JavaScript. Today, JavaScript has a great number of different environments where it can be executed - each with its own peculiarities.

This chapter intends to explain how to use _ClojureScript_ without any additional tooling. This will help you understand how the compiler works and how you can use it when other tooling is not available (such as link:http://leiningen.org/[leiningen] + link:https://github.com/emezeske/lein-cljsbuild[cljsbuild] or link:http://boot-clj.com/[boot]).


==== Execution environments

What is an execution environment? An execution environment is an engine where JavaScript can be executed. For example, the most popular execution environment is a browser (Chrome, Firefox, ...) followed by the second most popular - link:https://nodejs.org/[nodejs].

There are others, such as Rhino (JDK 6+), Nashorn (JDK 8+), QtQuick (QT),... but none of them have significant differences from the first two. So, _ClojureScript_ at the moment may compile code to run in the browser or in nodejs-like environments out of the box.


==== Download the compiler

The fastest way to obtain all the tooling needed for ClojureScript compilaition is installing the Clojure CLI Tools:

[source, bash]
----
curl -O https://download.clojure.org/install/linux-install-1.10.1.462.sh
chmod +x linux-install-1.10.1.462.sh
sudo ./linux-install-1.10.1.462.sh
----

If you are using other operating system other than linux, refer to https://clojure.org/guides/getting_started page.

Although the _ClojureScript_ is self hosted, in this book we will use the JVM implementation, with in turn requires JDK8 or JDK11 installed. You can obtain it using your distribution default package manager or download it from link:https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html[Oracle] or link:https://www.azul.com/downloads/zulu-community/[Azul]

.Example installing it using a apt in a debian-like distribution
[source, bash]
----
sudo apt-get install openjdk-8-jdk rlwrap
----

==== Compile for Node.js

Let’s start with a practical example compiling code that will target *Node.js*
(hereafter simply "nodejs"). For this example, you should have nodejs installed.

There are different ways to install nodejs, but the recommended way is using nvm ("Node.js Version Manager"). You can read the instructions on how to install and use nvm on its link:https://github.com/creationix/nvm[home page].

When you have installed nvm, follow installing the latest version of nodejs:

[source, shell]
----
nvm install v10.16.0
nvm alias default v10.16.0
----

You can test if *nodejs* is installed in your system with this command:

[source, shell]
----
$ node --version
v10.16.0
----


===== Create the example application

For the first step of our practical example, we will create our application directory structure and populate it with example code.

Start by creating the directory tree structure for our “hello world” application:

[source, bash]
----
mkdir -p myapp/src/myapp
touch myapp/src/myapp/core.cljs
----

Resulting in this directory tree:

[source, text]
----
myapp
└── src
    └── myapp
        └── core.cljs
----


Second, write the example code into the previously created `myapp/src/myapp/core.cljs` file:

[source, clojure]
----
(ns myapp.core
  (:require [cljs.nodejs :as nodejs]))

(nodejs/enable-util-print!)

(defn -main
  [& args]
  (println "Hello world!"))

(set! *main-cli-fn* -main)
----

NOTE: It is very important that the declared namespace in the file exactly matches the directory structure. This is the way _ClojureScript_ structures its source code.

And finally, lets create the `myapp/deps.edn` declaring the clojure and clojurescript versions:

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}}
 :paths ["src"]}
----


===== Compile the example application

In order to compile that source code, we need a simple build script that tells the _ClojureScript_ compiler the source directory and the output file. _ClojureScript_ has a lot of other options, but at this moment we can ignore that.

Let’s create the `myapp/build.clj` file with the following content:

[source, clojure]
----
(require '[cljs.build.api :as b])

(b/build "src" {:main 'myapp.core
                :output-to "main.js"
                :output-dir "out"
                :target :nodejs
                :verbose true})
----

This is a brief explanation of the compiler options used in this example:

* The `:output-to` parameter indicates to the compiler the destination of the compiled code, in this case to the "main.js" file.
* The `:main` property indicates to the compiler the namespace that will act as the entry point of your application when it's executed.
* The `:target` property indicates the platform where you want to execute the compiled code. In this case, we are going to use *nodejs*. If you omit this parameter, the source will be compiled to run in the browser environment.

To run the compilation, just execute the following command:

[source, bash]
----
cd myapp
clojure build.clj
----

And when it finishes, execute the compiled file using *node*:

[source, shell]
----
$ node main.js
Hello world!
----


==== Compile for the Browser

In this section we are going to create an application similar to the "hello world" example from the previous section to run in the browser environment. The minimal requirement for this application is just a browser that can execute JavaScript.

The process is almost the same, and the directory structure is the same. The only things that changes is the entry point of the application and the build script. So, start re-creating the directory tree from previous example in a different directory.

[source, bash]
----
mkdir -p mywebapp/src/mywebapp
touch mywebapp/src/mywebapp/core.cljs
----

Resulting in this directory tree:

[source, text]
----
mywebapp
└── src
    └── mywebapp
        └── core.cljs
----

Then, write new content to the `mywebapp/src/mywebapp/core.cljs` file:

[source, clojure]
----
(ns mywebapp.core)

(enable-console-print!)

(println "Hello world!")
----

In the browser environment we do not need a specific entry point for the application, so the entry point is the entire namespace.


===== Compile the example application

In order to compile the source code to run properly in a browser, overwrite the `mywebapp/build.clj` file with the following content:

[source, clojure]
----
(require '[cljs.build.api :as b])

(b/build "src" {:output-to "main.js"
                :source-map true
                :output-dir "out/"
                :main 'mywebapp.core
                :verbose true
                :optimizations :none})
----

This is a brief explanation of the compiler options we're using:

* The `:output-to` parameter indicates to the compiler the destination of the compiled code, in this case the "main.js" file.
* The `:main` property indicates to the compiler the namespace that will act as the  entry point of your application when it's executed.
* `:source-map` indicates the destination of the source map. (The source map connects the ClojureScript source to the generated JavaScript so that error messages can point you back to the original source.)
* `:output-dir` indicates the destination directory for all file sources used in a compilation. It is just for making source maps work properly with the rest of the code, not only your source.
* `:optimizations` indicates the compilation optimization. There are different values for this option, but that will be covered in subsequent sections in more detail.

To run the compilation, just execute the following command:

[source, bash]
----
cd mywebapp;
clojure build.clj
----

This process can take some time, so do not worry; wait a little bit. The JVM bootstrap with the Clojure compiler is slightly slow. In the following sections, we will explain how to start a watch process to avoid constantly starting and stopping this slow process.

While waiting for the compilation, let's create a dummy HTML file to make it easy to execute our example app in the browser. Create the _index.html_ file with the following content; it goes in the main _mywebapp_ directory.

[source, html]
----
<!DOCTYPE html>
<html>
  <header>
    <meta charset="utf-8" />
    <title>Hello World from ClojureScript</title>
  </header>
  <body>
    <script src="main.js"></script>
  </body>
</html>
----

Now, when the compilation finishes and you have the basic HTML file you can just open it with your favorite browser and take a look in the development tools console. The "Hello world!" message should appear there.


==== Watch process

You may have already noticed the slow startup time of the _ClojureScript_ compiler. To solve this, the _ClojureScript_ standalone compiler comes with a tool to watch for changes in your source code, and re-compile modified files as soon as they are written to disk.

Let's start converting our build.clj script to something that can accept arguments and execute different tasks. Let's create a `tools.clj` script file with the following content:

[source, clojure]
----
(require '[cljs.build.api :as b])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-> task methods (dissoc :default) keys sort)
        interposed (->> all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(def build-opts
  {:output-to "main.js"
   :source-map true
   :output-dir "out/"
   :main 'mywebapp.core
   :verbose true
   :optimizations :none})

(defmethod task "build"
  [args]
  (b/build "src" build-opts))

(defmethod task "watch"
  [args]
  (b/watch"src" build-opts))

(task *command-line-args*)
----

Now you can start the watch process with the following command:

[source, bash]
----
clojure tools.clj watch
----

Go back to the `mywebapp.core` namespace, and change the print text to `"Hello World, Again!"`.  You'll see that the file `src/mywebapp/core.cljs` the file is immediately recompiled, and if you reload `index.html` in your browser the new text is displayed in the developer console.

You also can start the simple build with:

[source, bash]
----
clojure tools.clj build
----

And finally, if you execute the `build.clj` script with no params, a help message with available "tasks" will be printed:

[source, bash]
----
$ clojure tools.clj
Unknown or missing task. Choose one of: build, watch
----


==== Optimization levels

The _ClojureScript_ compiler has different levels of optimization. Behind the scenes, those compilation levels are coming from the Google Closure Compiler.

A simplified overview of the compilation process is:

1. The reader reads the code and does some analysis. This compiler may raise some warnings during this phase.
2. Then, the _ClojureScript_ compiler emits JavaScript code. The result is one JavaScript output file for each ClojureScript input file.
3. The generated JavaScript files are passed through the Google Closure Compiler which, depending on the optimization level and other options (sourcemaps, output dir output to, ...), generates the final output file(s).

The final output format depends on the optimization level chosen:


===== none

This optimization level causes the generated JavaScript to be written into separate output files for each namespace, without any additional transformations to the code.


===== whitespace

This optimization level causes the generated JavaScript files to be concatenated into a single output file, in dependency order.  Line breaks and other whitespace are removed.

This reduces compilation speed somewhat, resulting in a slower compilations. However, it is not terribly slow and it is quite usable for small-to-medium sized applications.

===== simple

The simple compilation level builds on the work from the `whitespace` optimization level, and additionally performs optimizations within expressions and functions, such as renaming local variables and function parameters to have shorter names.

Compilation with the `:simple` optimization always preserves the functionality of syntactically valid JavaScript, so it does not interfere with the interaction between the compiled _ClojureScript_ and other JavaScript.


===== advanced

The advanced compilation level builds on the `simple` optimization level, and
additionally performs more aggressive optimizations and dead code elimination. This
results in a significantly smaller output file.

The `:advanced` optimizations only work for a strict subset of JavaScript which follows the Google Closure Compiler rules.  _ClojureScript_ generates valid JavaScript within this strict subset, but if you are interacting with third party JavaScript code, some additional work is required to make everything work as expected.

This interaction with third party javascript libraries will be explained in later sections.


=== Working with the REPL

////
TODO: maybe it would be interesting to take some ideas from
http://www.alexeberts.com/exploring-the-clojurescript-repl/
////


==== Introduction

Although you can create a source file and compile it every time you want to try something out in ClojureScript, it's easier to use the REPL. REPL stands for:

* Read - get input from the keyboard
* Evaluate the input
* Print the result
* Loop back for more input

In other words, the REPL lets you try out ClojureScript concepts and get immediate feedback.

_ClojureScript_ comes with support for executing the REPL in different execution environments, each of which has its own advantages and disadvantages. For example, you can run a REPL in nodejs but in that environment you don't have any access to the DOM.  Which REPL environment is best for you depends on your specific needs and requirements.


==== Nashorn REPL

The Nashorn REPL is the easiest and perhaps most painless REPL environment because it does not require any special stuff.

Let’s start creating a new script file for our repl playground called `tools.clj` in a new directory (in our case `repl_playground/tools.clj`):

[source, clojure]
----
(require '[cljs.repl :as repl])
(require '[cljs.repl.nashorn :as nashorn])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-> task methods (dissoc :default) keys sort)
        interposed (->> all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(defmethod task "repl:nashorn"
  [args]
  (repl/repl (nashorn/repl-env)
             :output-dir "out/nashorn"
             :cache-analysis true))

(task *command-line-args*)
----

Create the `repl_playground/deps.edn` file with the following content (identical from previous examples):

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}}
 :paths ["src"]}
----

And now, we can execute the REPL:

[source, bash]
----
$ clj tools.clj repl:nashorn
ClojureScript 1.10.520
cljs.user=> (prn "Hello world")
"Hello world"
nil
----

You may have noticed that in this example we have used `clj` command instead of `clojure`. That two commands are practically identical, the main difference is that `clj` executes `clojure` command wrapped in `rlwrap`. The `rlwrap` tool gives the "readline" capabilities which enables history, code navigation, and other shell-like features that will make your REPL experience much more pleasant.

If you don't have installed it previously, you can install it with `sudo apt install -y rlwrap`.

NOTE: This is a basic repl, in the following chapters we will explain how to have a more advanced repl experience with code-highlighting, code-completion and multiline edition.


==== Node.js REPL

You must, of course, have nodejs installed on your system to use this REPL.

You may be wondering why we might want a nodejs REPL, when we already have the nashorn REPL available which doesn't have any external dependencies. The answer is very simple: nodejs is the most used JavaScript execution environment on the backend, and it has a great number of community packages built around it.

The good news is that starting a nodejs REPL is very easy once you have it installed in your system. Start adding the following content into `tools.clj` script:

[source, clojure]
----
(require '[cljs.repl.node :as node])

(defmethod task "node:repl"
  [args]
  (repl/repl (node/repl-env)
             :output-dir "out/nodejs"
             :cache-analysis true))
----

And start the REPL:

[source,bash]
----
$ clj tools.clj repl:node
ClojureScript 1.10.520
cljs.user=> (prn "Hello world")
"Hello world"
nil
----


==== Browser REPL

This REPL is the most laborious to get up and running. This is because it uses a browser for its execution environment and it has additional requirements.

Let’s start by adding the following content to the `tools.clj` script file:

[source, clojure]
----
(require '[cljs.build.api :as b])
(require '[cljs.repl.browser :as browser])

(defmethod task "repl:browser"
  [args]
  (println "Building...")
  (b/build "src"
           {:output-to "out/browser/main.js"
            :output-dir "out/browser"
            :source-map true
            :main 'myapp.core
            :optimizations :none})

  (println "Launching REPL...")
  (repl/repl (browser/repl-env :port 9001)
             :output-dir "out/browser"))
----

The main difference with the previous examples, is that browser REPL requires that some code be execution in the browser before the REPL gets working. To do that, just re-create the application structure very similar to the one that we have used in previous sections:

[source, bash]
----
mkdir -p src/myapp
touch src/myapp/core.cljs
----

Then, write new content to the `src/myapp/core.cljs` file:

[source, clojure]
----
(ns myapp.core
 (:require [clojure.browser.repl :as repl]))

(defonce conn
  (repl/connect "http://localhost:9001/repl"))

(enable-console-print!)

(println "Hello, world!")
----

And finally, create the missing _index.html_ file that is going to be used as the entry point for running the browser side code of the REPL:

[source, html]
----
<!DOCTYPE html>
<html>
  <header>
    <meta charset="utf-8" />
    <title>Hello World from ClojureScript</title>
  </header>
  <body>
    <script src="out/browser/main.js"></script>
  </body>
</html>
----

Well, that was a lot of setup! But trust us, it’s all worth it when you see it in action. To do that, just execute the `tools.clj` in the same way that we have done it in previous examples:

[source, bash]
----
$ clj tools.clj repl:browser
Building...
Launching REPL...
ClojureScript 1.10.520
cljs.user=>
----

And finally, open your favourite browser and go to http://localhost:9001/. Once the page is loaded (the page will be blank), switch back to the console where you have run the REPL and you will see that it is up and running:

[source, bash]
----
[...]
To quit, type: :cljs/quit
cljs.user=> (+ 14 28)
42
----

One of the big advantages of the browser REPL is that you have access to everything in the browser environment. For example, type `(js/alert "hello world")` in the REPL. This will cause the browser to display an alert box. Nice!

NOTE: This is just a preview of how to use the builtin REPL capabilities of the ClojureScript compiler. There are better and more user/developer friendly repl environments with code-highlighting, code-completion and multiline edition (and in case of web development, also with code hot reloading) that will be explained in the following chapters.


==== Rebel Readline (REPL library)

This is a library that adds more advanced features to the Clojure(Script) builtin REPL and enables code-highlighting, code-completion and multiline edition.

Let's start adding rebel dependency into `deps.edn` file:

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}
        com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}
        com.bhauman/rebel-readline {:mvn/version "0.1.4"}}
 :paths ["src"]}
----

And adding the followin code to the `tools.clj` script file:

[source, clojure]
----
(require '[rebel-readline.core]
         '[rebel-readline.clojure.main]
         '[rebel-readline.clojure.line-reader]
         '[rebel-readline.cljs.service.local]
         '[rebel-readline.cljs.repl])

(defmethod task "repl:rebel:node"
  [args]
  (rebel-readline.core/with-line-reader
    (rebel-readline.clojure.line-reader/create
     (rebel-readline.cljs.service.local/create))
    (repl/repl (node/repl-env)
               :prompt (fn [])
               :read (rebel-readline.cljs.repl/create-repl-read)
               :output-dir "out/nodejs"
               :cache-analysis true)))
----

And start the REPL:

[source, bash]
----
$ clojure tools.clj repl:rebel:node
ClojureScript 1.10.520
cljs.user=> (println)
cljs.core/println: ([& objs])
----

You can find that while you writing in the repl, it automatically suggest and shows se function signature that you want to execute.

You can find more information about all rebel-readline capabilities on https://github.com/bhauman/rebel-readline



=== The Closure Library

The Google Closure Library is a javascript library developed by Google. It has a modular architecture, and provides cross-browser functions for DOM manipulations and events, ajax and JSON, and other features.

The Google Closure Library is written specifically to take advantage of the Closure Compiler (which is used internally by the _ClojureScript_ compiler).

_ClojureScript_ is built on the Google Closure Compiler and Closure Library. In fact, _ClojureScript_ namespaces are Closure modules. This means that you can interact with the Closure Library very easily:

[source, clojure]
----
(ns yourapp.core
  (:require [goog.dom :as dom]))

(def element (dom/getElement "body"))
----

This code snippet shows how you can import the *dom* module of the Closure library and use a function declared in that module.

Additionally, the closure library exposes "special" modules that behave like a class or object. To use these features, you must use the `:import` directive in the `(ns ...)` form:

[source, clojure]
----
(ns yourapp.core
  (:import goog.History))

(def instance (History.))
----

In a _Clojure_ program, the `:import` directive is used for host (Java) interop to import Java classes.  If, however, you define types (classes) in _ClojureScript_, you should use the standard `:require` directive and not the `:import` directive.

You can found the reference to all namespaces in the closure library here:
http://google.github.io/closure-library/api/


=== Dependency management

Until now, we have used the builtin _Clojure(Script)_ toolchain to compile our source files to JavaScript. Now this is a time to understand how manage external and/or third party dependencies.


==== First project

The best way to show how a tool works is by creating a toy project with it. In this case, we will create a small application that determines if a year is a leap year or not.

Let's start creating the project layout:

[source, bash]
----
mkdir -p leapyears/src/leapyears
mkdir -p leapyears/target/public
touch leapyears/target/public/index.html
touch leapyears/src/leapyears/core.cljs
touch leapyears/tools.cljs
touch leapyears/deps.edn
----

The project has the following structure:

----
leapyears
├── deps.edn
├── src
│   └── leapyears
│       └── core.cljs
├── target
│   └── public
│       └── index.html
└── tools.clj
----

The `deps.edn` file contains information about all the *packaged* dependencies needed to build or execute the application. Packaged dependencies are libraries packaged as jar files and uploaded to clojars/maven repository.

[NOTE]
====
But ClojureScript can consume external code in many different ways:

- google closure library module
- global export module
- es6/commonjs module (experimental)

This will be explained in the following sections.
====

Let's start with a simple `deps.edn` file:

[source, clojure]
----
{:deps {org.clojure/clojurescript {:mvn/version "1.10.520"}
        org.clojure/clojure {:mvn/version "1.10.1"}
        com.bhauman/rebel-readline-cljs {:mvn/version "0.1.4"}
        com.bhauman/rebel-readline {:mvn/version "0.1.4"}}
 :paths ["src" "target"]}
----

And simple build script (`tools.clj` file):

[source, clojure]
----
(require '[cljs.build.api :as b])
(require '[cljs.repl :as repl])
(require '[cljs.repl.node :as node])

(defmulti task first)

(defmethod task :default
  [args]
  (let [all-tasks  (-> task methods (dissoc :default) keys sort)
        interposed (->> all-tasks (interpose ", ") (apply str))]
    (println "Unknown or missing task. Choose one of:" interposed)
    (System/exit 1)))

(def build-opts
  {:output-to "target/public/js/leapyears.js"
   :source-map true
   :output-dir "target/public/js/leapyears"
   :main 'leapyears.core
   :verbose true
   :optimizations :none})

(defmethod task "repl"
  [args]
  (repl/repl (node/repl-env)
             :output-dir "target/nodejs"
             :cache-analysis true))

(defmethod task "build"
  [args]
  (b/build "src" build-opts))

(defmethod task "watch"
  [args]
  (b/watch "src" build-opts))

(task *command-line-args*)
----

Then, write the following content into `target/public/index.html` file:

[source, html]
----
<!DOCTYPE html>
<html>
  <head>
    <title>leapyears</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  </head>
  <body>
    <section class="viewport">
      <div id="result">
        ----
      </div>

      <form action="" method="">
        <label for="year">Input a year</label>
        <input id="year" name="year" />
      </form>
    </section>

    <script src="./js/leapyears.js" type="text/javascript"></script>
  </body>
</html>
----

The next step consist in add some code to make the form interactive. Put the following code into the `src/leapyears/core.cljs`:

[source, clojure]
----
(ns leapyears.core
  (:require [goog.dom :as dom]
            [goog.events :as events]
            [cljs.reader :refer (read-string)]))

(enable-console-print!)

(def input (dom/getElement "year"))
(def result (dom/getElement "result"))

(defn leap?
  [year]
  (or (zero? (js-mod year 400))
      (and (pos? (js-mod year 100))
           (zero? (js-mod year 4)))))

(defn on-change
  [event]
  (let [target (.-target event)
        value (read-string (.-value target))]
    (if (leap? value)
      (set! (.-innerHTML result) "YES")
      (set! (.-innerHTML result) "NO"))))

(events/listen input "keyup" on-change)
----

Now, we can compile the project with:

[source, bash]
----
clojure tools.clj watch
----

Finally, open the `target/public/index.html` file in a browser. Typing a year in the textbox should display an indication of its leap year status.


==== Adding native dependencies

Until now we have used only the batteries included in the ClojureScript runtime, let improve our project including a native dependency. In this example we will use the link:https://github.com/funcool/cuerdas[Cuerdas] (a string manipulation library build especifically for Clojure(Script)).

Add `funcool/cuerdas {:mvn/version "2.2.0"}` into the `:deps` section inside the `deps.edn` file. And add the corresponding modifications to the `leapyears/core.cljs` file:

[source, clojure]
----
(ns leapyears.core
  (:require [goog.dom :as dom]
            [goog.events :as events]
            [cuerdas.core :as str]
            [cljs.reader :refer (read-string)]))

;; [...]

(defn on-change
  [event]
  (let [target (.-target event)
        value (read-string (.-value target))]

    (if (str/blank? value)
      (set! (.-innerHTML result) "---")
      (if (leap? value)
        (set! (.-innerHTML result) "YES")
        (set! (.-innerHTML result) "NO")))))
----

Now, if you run the build or watch command, the new declared dependency will be downloaded and the application will be compiled with this dependency included.

Clojure packages are often published on link:http://clojars.org[Clojars]. You can also find many third party libraries on the link:https://github.com/clojure/clojurescript/wiki#libraries[ClojureScript Wiki].


==== External dependencies

In some circumstances you may found yourself that you need some library but that does not exists in _ClojureScript_ but it is already implemented in javascript and you want to use it on your project.

There are many ways that you can do it mainly depending on the library that you want to include. Many of that libraries are packaged and uploaded to clojars, so you can declare them in the `deps.edn` in the same way as native dependencies (with some peculirities in usage, see below).


==== Closure compatible module

If you have a library that is written to be compatible with google closure module system and you want to include it on your project: put the source into the classpath (inside `src` or `vendor` directory in leapyears project) and access it like any other clojure namespace.

This is the most simplest case, because google closure modules are directly compatible and you can mix your clojure code with javascript code written using google closure module system without any additional steps.

Reusing the leapyears project, lets implement the `leap?` function in a javascript using google closure module format. Start creating the directory structure:

[source, bash]
----
touch src/leapyears/util.js
----

And add the implementation using closure module format:

.src/leapyears/util.js
[source, js]
----
goog.provide("leapyears.util");

goog.scope(function() {
  var module = leapyears.util;

  module.isLeap = function(val) {
    return (0 === (val % 400)) || (((val % 100) > 0) && (0 === (val % 4)));
  };
});
----

Now, if you open the repl, you can import the namespace and use the `isLeap` function

[source, clojure]
----
(require '[leapyears.util :as util])

(util/isLeap 2112)
;; => true

(util/isLeap 211)
;; => false
----

NOTE: you can open the nodejs repl just executing `clj tools.clj repl` in the root of the project.

NOTE: this is the approach used by many projects to implement some performance sensitive logic directly in javascript and export it in an easy way to ClojureScript


==== Global Export

This is the most extended and the most reliable way to consume external javascript libraries from ClojureScript and it has many facilities.

Let's play with that. Start creating a simple file using commonjs module format (pretty analogous to the previous example using google closure modules):

The fastest way to include a javascript library is looking if it is available in link:http://cljsjs.github.io/[CLJSJS]. If it is available, just include the dependency in the `deps.edn` file and use it.

That libraries has two ways of use it, let's see some examples.

Start adding `moment` dependency to `deps.edn` file:

[source, clojure]
----
cljsjs/moment {:mvn/version "2.24.0-0"}
----

Then, open the repl and try the following:

.using the `js/` special namespace
[source, clojure]
----
(require '[cljsjs.moment]) ;; just require, no alias

(.format (js/moment) "LLLL")
;; => "Monday, July 15, 2019 5:32 PM"
----

.using the alias
[source, clojure]
----
(require '[moment :as m])

(.format (m) "LLLL")
;; => "Monday, July 15, 2019 5:33 PM"
----

Behind the scenes that packages uses the ClojureScript compiler facilities link:https://clojurescript.org/reference/compiler-options#foreign-libs[descibed here] for provide the compiler with enough information about the files and global exports to use.

So, if don't find a library in cljsjs, we can include it using the same facilities. Let's assume that moment is not available on cljsjs and we need it on our project.

For include an foreign dependency we need to pass `:foreign-libs` and `:externs` params to the ClojureScript compiler, and we have two ways:

- passing them to the `build` or `repl` functions.
- inside the `deps.cljs` file located on the root of the classpath.

The `deps.cljs` approach requires that files should be localted on the local directories, but the first approach allows specify directly external urls. We will use the first approach on our example.

This is how looks the `deps.edn` file with the changes applied:

[source, clojure]
----
;; [...]

(def foreign-libs
  [{:file "https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.js"
    :file-min "https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"
    :provides ["vendor.moment"]}])


(def build-opts
  {:output-to "target/public/js/leapyears.js"
   :source-map true
   :output-dir "target/public/js/leapyears"
   :main 'leapyears.core
   :verbose true
   :optimizations :none
   :foreign-libs foreign-libs})

(defmethod task "repl"
  [args]
  (repl/repl (node/repl-env)
             :foreign-libs foreign-libs
             :output-dir "target/node"
             :cache-analysis true))

;; [...]
----

Now, if you excute the repl, you will be able to import `vendor.moment` in the same way if you are using the cljsjs package.

Finally, there are the `:externs` option, that will be needed only for the production build, and the externs file consists in plain javascript files that declares the public API of the included foreign libraries and make them understandable to the google closure compiler.

The moment externs are available link:https://github.com/cljsjs/packages/blob/master/moment/resources/cljsjs/common/moment.ext.js[here] and if you include some library that you want to use, and then want to compile your app with advanced optimizations you will need to include a file similar to the moment.ext.js on the project and referenciate it with `:externs` option to the ClojureScript compiler.

More info link:https://clojurescript.org/reference/compiler-options#externs[on clojurescript.org].


==== ES6/CommonJS modules

Google Closure Compiler has an advanced feature that allows convert from different module types (commonjs and ES) into google closure module type. Although this feature is still experimental. With simple modules it works, but with more complex modules (many submodules and directories) still doest not complies correctly.

In any way I invite you to experiment with it. You can found more documentation on link:https://clojurescript.org/reference/javascript-module-support[clojurescript.org].

The best way to use ES6 and/or CommonJS module is combining a javascript bundler like _rollup_ or _webpack_ to generate a single build with external dependencies and thn use the *global exports* method to use it in ClojureScript. An example of this is explained link:https://clojurescript.org/guides/webpack[on clojurescript.org].


=== Interactive development with Figwheel

And finally we will introduce *figwheel*, that enables fully interactive, REPL-based and hot reloading enabled development environment.

We will reuse the leapyears project structure for the following examples.

NOTE: Although we use figwheel here for web application, it works in the same way on the application that targets nodejs as execution environment.

As first step, we need to add *figwheel* dependency to the `deps.edn` file:

[source, clojure]
----
com.bhauman/figwheel-main {:mvn/version "0.2.1"}
----

Then, add new task to the `tools.clj` script:

[source, clojure]
----
(def figwheel-opts
  {:open-url false
   :load-warninged-code true
   :auto-testing false
   :ring-server-options {:port 3448 :host "0.0.0.0"}
   :watch-dirs ["src"]})

(defmethod task "figwheel"
  [args]
  (figwheel/start figwheel-opts {:id "main" :options build-opts}))
----


And then, run `clojure tools.clj fighweel`. This will start the figwheel process that automatically will launch a http server that will serve the `target/public/` directory and index to `index.html` file.

If you update the code, that code will be automatically loaded to the browser, *without page reload*.

For more info: link:https://figwheel.org/[figwheel.org].


=== Unit testing

As you might expect, testing in _ClojureScript_ consists of the same concepts widely used by other language such as Clojure, Java, Python, JavaScript, etc.

Regardless of the language, the main objective of unit testing is to run some test cases, verifying that the code under test behaves as expected and returns without raising unexpected exceptions.

The immutablity of _ClojureScript_ data structures helps to make programs less error prone, and facilitates testing a little bit. Another advantage of _ClojureScript_ is that it tends to use plain data instead of complex objects. Building "mock" objects for testing is thus greatly simplified.


==== First steps

The "official" _ClojureScript_ testing framework is in the "cljs.test" namespace. It is a very simple library, but it should be more than enough for our purposes.

There are other libraries that offer additional features or directly different approaches to testing, such as link:https://github.com/clojure/test.check[test.check]. However, we will not cover them here.

We will reuse the `leapyears` project structure and we will add testing to it. Let's create the test related files and directories:

[source, bash]
----
mkdir -p test/leapyears/test
touch test/leapyears/test/main.cljs
----

Also we will need to create new tasks on our `tools.clj` file for build, watch and run tests:

[source, clojure]
----
(require '[clojure.java.shell :as shell])

;; [...]

(defmethod task "build:tests"
  [args]
  (b/build (b/inputs "src" "vendor" "test")
           (assoc build-opts
                  :main 'leapyears.test.main
                  :output-to "out/tests.js"
                  :output-dir "out/tests"
                  :target :nodejs)))

(defmethod task "watch:test"
  [args]
  (letfn [(run-tests []
            (let [{:keys [out err]} (shell/sh "node" "out/tests.js")]
              (println out err)))]
    (println "Start watch loop...")
    (try
      (b/watch (b/inputs "src", "test")
               (assoc build-opts
                      :main 'leapyears.test.main
                      :watch-fn run-tests
                      :output-to "out/tests.js"
                      :output-dir "out/tests"
                      :target :nodejs))

      (catch Exception e
        (println "Error on running tests:" e)
        ;; (Thread/sleep 2000)
        (task args)))))
----

Next, put some test code in the `test/leapyears/test/main.cljs` file:

[source, clojure]
----
(ns leapyears.test.main
  (:require [cljs.test :as t]))

(enable-console-print!)

(t/deftest my-first-test
  (t/is (= 1 2)))

(set! *main-cli-fn* #(t/run-tests))

;; This extension is required for correctly set the return code depending if the test passes or not
(defmethod t/report [:cljs.test/default :end-run-tests]
  [m]
  (if (t/successful? m)
    (set! (.-exitCode js/process) 0)
    (set! (.-exitCode js/process) 1)))
----

The relevant part of that code snippet is:

[source, clojure]
----
(t/deftest my-first-test
  (t/is (= 1 2)))
----

The `deftest` macro is a basic primitive for defining our tests. It takes a name as its first parameter, followed by one or multiple assertions using the `is` macro. In this example, we try to assert that `(= 1 2)` is true.

Let's try to run this:

[source,bash]
----
$ clojure tools build:tests
$ node out/tests.js
Testing mytestingapp.core-tests

FAIL in (my-first-test) (cljs/test.js:374:14)
expected: (= 1 2)
  actual: (not (= 1 2))

Ran 1 tests containing 1 assertions.
1 failures, 0 errors.
----

You can see that the expected assert failure is successfully printed in the console. To fix the test, just change the `=` with `not=` and run the file again:

[source, bash]
----
$ clojure tools build:tests
$ node out/mytestingapp.js

Testing mytestingapp.core-tests

Ran 1 tests containing 1 assertions.
0 failures, 0 errors.
----

It is fine to test these kinds of assertions, but they are not very useful. Let's go to test some application code. For this, we will use a function to check if a year is a leap year or not:

[source, clojure]
----
(ns leapyears.test.main
  (:require [cljs.test :as t]
            [leapyears.vendor.util-closure :as util]))

;; [...]

(t/deftest my-second-test
  (t/is (util/isLeap 1980))
  (t/is (not (util/isLeap 1981))))

;; [...]
----

Run the compiled file again to see that there are now two tests running.  The first test passes as before, and our two new leap year tests pass as well.


==== Async Testing

One of the peculiarities of _ClojureScript_ is that it runs in an asynchronous, single-threaded execution environment, which has its challenges.

In an async execution environment, we should be able to test asynchronous functions. To this end, the _ClojureScript_ testing library offers the `async` macro, allowing you to create tests that play well with asynchronous code.

First, we need to write a function that works in an asynchronous way. For this purpose, we will create the `async-leap?` predicate that will do the same operation but asychronously return a result using a callback:

[source, clojure]
----
(defn async-leap?
  [year callback]
  (js/setImmediate #(callback (util/isLeap year))))
----

The JavaScript function `setImmediate` is used to emulate an asynchronous task, and the callback is executed with the result of that predicate.

To test it, we should write a test case using the previously mentioned `async` macro:

[source, clojure]
----
(t/deftest my-async-test
  (t/async done
    (async-leap? 1980 (fn [result]
                        (t/is (true? result))
                              (done)))))
----

The `done` function exposed by the `async` macro should be called after the asynchronous operation is finished and all assertions have run.

It is very important to execute the `done` function only once. Omitting it or executing it twice may cause strange behavior and should be avoided.
