=== Transducers

==== Data transformation

ClojureScriptは、シーケンス抽象化の観点から、データ変換のための豊富な語彙を提供しており、このような変換を非常に汎用的かつ複合的に行うことができます。それでは、いくつかのコレクション処理関数を組み合わせて新しい関数を構築する方法を見てみましょう。このセクションでは、ブドウの房を分割し、腐ったもの(rotten)を取り除き、きれいにするという簡単な問題を取り上げます。以下のようなブドウの房のコレクションがあります。

[source, clojure]
----
(def grape-clusters
  [{:grapes [{:rotten? false :clean? false}
             {:rotten? true :clean? false}]
    :color :green}
   {:grapes [{:rotten? true :clean? false}
             {:rotten? false :clean? false}]
    :color :black}])
----

ブドウの房を個々のブドウに分割し、腐った(rotten)ブドウを捨て、残りのブドウをきれいにして食べられるようにすることに興味があります。ClojureScriptには、このデータ変換タスクのための十分な装備があります。おなじみの `map` 、 `filter` 、 `mapcat` 関数を使って実装できます。

[source, clojure]
----
(defn split-cluster
  [c]
  (:grapes c))

(defn not-rotten
  [g]
  (not (:rotten? g)))

(defn clean-grape
  [g]
  (assoc g :clean? true))

(->> grape-clusters
     (mapcat split-cluster)
     (filter not-rotten)
     (map clean-grape))
;; => ({rotten? false :clean? true} {:rotten? false :clean? true})
----

上の例では、ブドウを選んできれいにするという問題を簡潔に解決しましたが、部分適用や関数合成を用いて、 `mapcat` 、 `filter` 、 `map` の各操作を組み合わせることで、このような変換を抽象化することもできます。

[source, clojure]
----
(def process-clusters
  (comp
    (partial map clean-grape)
    (partial filter not-rotten)
    (partial mapcat split-cluster)))

(process-clusters grape-clusters)
;; => ({rotten? false :clean? true} {:rotten? false :clean? true})
----

このコードはとてもきれいですが、いくつかの問題があります。例えば、 `map` 、 `filter` 、 `mapcat` の各呼び出しは、シーケンスを消費して生成します。このシーケンスは、遅延しているとはいえ、破棄される中間結果を生成します。各シーケンスは次のステップに供給され、これもシーケンスを返します。もし、この変換を `grape-cluster` コレクションの1回の横断で行うことができたら、素晴らしいと思いませんか？

もうひとつの問題は、 `process-cluster` 関数がどんなシーケンスでも動作するにもかかわらず、シーケンスではないものでは再利用できないことです。例えば、ブドウ クラスターのコレクションがメモリ上にあるのではなく、ストリームで非同期にプッシュされてきたとします。このような状況では、 `process-clusters` を再利用することはできません。なぜなら、通常、 `map` 、 `filter` 、 `mapcat` は、型に応じて具体的な実装を持っているからです。


==== Generalizing to process transformations

map、filter、mapcatなどの処理は、必ずしも具体的な型に結びついているわけではありませんが、私たちはさまざまな型のためにそれらを再実装し続けています。このような処理をコンテキストに依存しないように一般化する方法を見てみましょう。まず最初に、`map`と`filter`の素朴なバージョンを実装して、内部でどのように動作するかを見てみましょう。

[source, clojure]
----
(defn my-map
  [f coll]
  (when-let [s (seq coll)]
    (cons (f (first s)) (my-map f (rest s)))))

(my-map inc [0 1 2])
;; => (1 2 3)

(defn my-filter
  [pred coll]
  (when-let [s (seq coll)]
    (let [f (first s)
          r (rest s)]
      (if (pred f)
        (cons f (my-filter pred r))
        (my-filter pred r)))))

(my-filter odd? [0 1 2])
;; => (1)
----

見ての通り、これらはどちらもseqableを受け取り、シーケンスを返すことを前提としています。多くの再帰関数と同様に，すでにおなじみの `reduce` 関数を用いて実装することができます．reduceに与えられた関数は，アキュムレータと入力を受け取り，次のアキュムレータを返すことに注意してください。今後はこのような関数をreduce関数と呼ぶことにします。

[source, clojure]
----
(defn my-mapr
  [f coll]
  (reduce (fn [acc input]         ;; reducing function
            (conj acc (f input)))
          []                      ;; initial value
          coll))                  ;; collection to reduce

(my-mapr inc [0 1 2])
;; => [1 2 3]

(defn my-filterr
  [pred coll]
  (reduce (fn [acc input]         ;; reducing function
            (if (pred input)
              (conj acc input)
              acc))
          []                      ;; initial value
          coll))                  ;; collection to reduce

(my-filterr odd? [0 1 2])
;; => [1]
----

以前のバージョンでは、 `reduce` を使うことで、配列だけでなく、還元可能なあらゆるものに対して関数が動作するようになっていたので、より一般的なものにしました。しかし、 `my-mapr` と `my-filterr` はソース( `coll` )について何も知らないにも関わらず、reduceの初期値( `[]` )とreduce関数の本体でハードコードされた `conj` 操作の両方で、生成される出力(ベクター)に結びついていることに気付いたかもしれません。結果を別のデータ構造、たとえば遅延シーケンスなどに蓄積することもできますが、そのためには関数を書き直さなければなりません。

これらの関数を真の意味で汎用的にするにはどうすればよいでしょうか。これらの関数は、変換する入力のソースや生成される出力のことを知らないはずです。conj "が単なる還元関数であることに気づいたでしょうか？この関数はアキュムレータと入力を受け取り、別のアキュムレータを返します。ですから、 `my-mapr` や `my-filterr` が使用する還元関数をパラメータ化すれば、構築している結果の型については何もわかりません。試しにやってみましょう。

[source, clojure]
----
(defn my-mapt
  [f]                         ;; function to map over inputs
  (fn [rfn]                   ;; parameterised reducing function
    (fn [acc input]           ;; transformed reducing function, now it maps `f`!
      (rfn acc (f input)))))

(def incer (my-mapt inc))

(reduce (incer conj) [] [0 1 2])
;; => [1 2 3]

(defn my-filtert
  [pred]                      ;; predicate to filter out inputs
  (fn [rfn]                   ;; parameterised reducing function
    (fn [acc input]           ;; transformed reducing function, now it discards values based on `pred`!
      (if (pred input)
        (rfn acc input)
        acc))))

(def only-odds (my-filtert odd?))

(reduce (only-odds conj) [] [0 1 2])
;; => [1]
----

たくさんの高次関数があるので、何が起こっているのかを理解するために分解してみましょう。 `my-mapt` がどのように動作するかを順を追って見ていきます。 `my-filtert` についても仕組みは似ているので、今回は割愛します。

まず、`my-mapt` はマッピング関数を受け取ります。例では `inc` を渡して、別の関数を返してもらっています。例では `inc` を与えて別の関数を返しています。`f` を `inc` に置き換えて、何を作っているのか見てみましょう。

[source, clojure]
----
(def incer (my-mapt inc))
;; (fn [rfn]
;;   (fn [acc input]
;;     (rfn acc (inc input))))
;;               ^^^
----

結果として得られる関数は、委譲先となるreducing関数を受け取るようにパラメータ化されていますが、これを `conj` で呼び出すとどうなるか見てみましょう。

[source, clojure]
----
(incer conj)
;; (fn [acc input]
;;   (conj acc (inc input)))
;;    ^^^^
----

入力を変換するために `inc` を使用し、結果を蓄積するために `conj` を使用する還元関数が返されます。本質的には、還元関数の変換としてmapを定義しています。 ある還元関数を別の還元関数に変換する関数をClojureScriptではトランスデューサと呼びます。

トランスデューサの一般性を説明するために、 `reduce` の呼び出しで異なるソースとデスティネーションを使用してみましょう。

[source, clojure]
----
(reduce (incer str) "" [0 1 2])
;; => "123"

(reduce (only-odds str) "" '(0 1 2))
;; => "1"
----

`map` と `filter` のトランスデューサバージョンは、入力をソースからデスティネーションに運ぶプロセスを変換しますが、入力がどこから来て出力がどこに終わるのかについては何も知りません。トランスデューサの実装では、コンテキストに依存せず、何を達成するかのエッセンスが含まれています。

トランスデューサについての知識が深まったところで、自分のバージョンの `mapcat` を実装してみましょう。基本的な部分はすでに持っています。それは `map` トランスデューサです。 `mapcat` が行うことは、入力に対して関数をマッピングし、結果として得られる構造を1レベル平坦化することです。では、トランスデューサとして結合(cat)の部分を実装してみましょう。

[source, clojure]
----
(defn my-cat
  [rfn]
  (fn [acc input]
    (reduce rfn acc input)))

(reduce (my-cat conj) [] [[0 1 2] [3 4 5]])
;; => [0 1 2 3 4 5]
----

`my-cat` トランスデューサは、入力をアキュムレータに結合(cat)する還元関数を返します。これは、還元関数 `rfn` で還元可能な `input` を還元し、その還元の初期値としてアキュムレータ ( `acc` ) を使用します。`mapcat` は `map` と `cat` を単純に組み合わせたものである。トランスデューサを構成する順序は後ろ向きに見えるかもしれませんが、すぐに明らかになります。

[source, clojure]
----
(defn my-mapcat
  [f]
  (comp (my-mapt f) my-cat))

(defn dupe
  [x]
  [x x])

(def duper (my-mapcat dupe))

(reduce (duper conj) [] [0 1 2])
;; => [0 0 1 1 2 2]
----


==== Transducers in ClojureScript core

`map` ,  `filter` ,  `mapcat` などの ClojureScript コア関数の中には、トランスデューサを返す引数が1つの バージョンをサポートしているものがあります。では、先ほどの `process-cluster` の定義をもう一度見直して、トランスデューサの観点から定義してみましょう。

[source, clojure]
----
(def process-clusters
  (comp
    (mapcat split-cluster)
    (filter not-rotten)
    (map clean-grape)))
----

前回の定義 `process-clusters` からいくつかの点が変更されました。まず、 `mapcat` ,  `filter` ,  `map`  をシーケンスの処理に部分的に適用するのではなく、トランスデューサを返すバージョンを使用しています。

また、気付いたかもしれませんが、これらの構成順は逆で、実行された順に並びます。すべての `map`, `filter`, `mapcat` はトランスデューサを返すことに注意してほしい。`filter` は `map` が返す還元関数を変換し、処理を進める前にフィルタリングを適用します。`mapcat` は `filter` が返す還元関数を変換し、処理を進める前にmapとcatを適用します。

トランスデューサの強力な特性の1つは、通常の関数合成を使って組み合わせられることです。 さらにエレガントなのは、さまざまなトランスデューサの組み合わせは、それ自体がトランスデューサであるということです。このことは、私たちの `process-cluster` もトランスデューサであることを意味します。つまり、私たちは合成可能でコンテキストに依存しないアルゴリズム変換を定義したことになります。

ClojureScriptのコア関数の多くはトランスデューサを受け入れるので、新しく作成した `process-cluster` でいくつかの例を見てみましょう。

[source, clojure]
----
(into [] process-clusters grape-clusters)
;; => [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]

(sequence process-clusters grape-clusters)
;; => ({:rotten? false, :clean? true} {:rotten? false, :clean? true})

(reduce (process-clusters conj) [] grape-clusters)
;; => [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]
----

トランスデューサーから返された還元関数で `reduce` を使用することは非常に一般的なので、 `transduce` と呼ばれる変換で還元するための関数があります。先ほどの `reduce` の呼び出しを `transduce` を使って書き換えることができます。

[source, clojure]
----
(transduce process-clusters conj [] grape-clusters)
;; => [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]
----


==== Initialisation

先の例では、 `transduce` 関数に初期値（ `[]` ）を与えましたが、これを省略しても同じ結果が得られます。

[source, clojure]
----
(transduce process-clusters conj grape-clusters)
;; => [{:rotten? false, :clean? true} {:rotten? false, :clean? true}]
----

ここで何が起こっているのでしょうか？初期値を指定していないのに、 `transduce` はどの初期値をアキュムレータとして使うかをどうやって知ることができるのでしょうか？引数なしで `conj` を呼んでみて、何が起こるか見てみましょう。

[source, clojure]
----
(conj)
;; => []
----

関数 `conj` には、空のベクトルを返す引数の数が0のバージョンがありますが、引数の数が0をサポートする還元関数はこれだけではありません。

[source, clojure]
----
(+)
;; => 0

(*)
;; => 1

(str)
;; => ""

(= identity (comp))
;; => true
----

トランスデューサが返す還元関数は、引数の数が0の場合もサポートしていなければならず、通常は変換された還元関数に委ねられます。これまでに実装したトランスデューサには、引数の数が0の適切な実装がありませんので、単に引数なしで還元関数を呼び出します。修正した `my-mapt` は以下のようになります。

[source, clojure]
----
(defn my-mapt
  [f]
  (fn [rfn]
    (fn
      ([] (rfn))                ;; 引数の数0で、還元関数fnに委ねる。
      ([acc input]
        (rfn acc (f input))))))
----

トランスデューサが返す還元関数の引数の数が0のものへの呼び出しは，入れ子になったすべての還元関数の引数の数が0であるバージョンを呼び出し，最終的には一番外側の還元関数を呼び出します．既に定義されている `process-clusters` トランスデューサを使って例を見てみましょう。

[source, clojure]
----
((process-clusters conj))
;; => []
----

引数の数が0の呼び出しはトランスデューサ・スタックを流れ、最終的には `(conj)` を呼び出します。


==== Stateful transducers

これまでのところ、純粋な関数型トランスデューサしか見ていません。これらのトランスデューサは暗黙的な状態を持たず、非常に予測可能です。しかし， `take` のように，本質的にステートフルなデータ変換関数は数多く存在します． `take` は保持する要素の数 `n` とコレクションを受け取り、最大で `n` 個の要素を持つコレクションを返します。

[source, clojure]
----
(take 10 (range 100))
;; => (0 1 2 3 4 5 6 7 8 9)
----

少し戻って、 `reduce` 関数の早期終了について学んでみましょう。アキュムレータを `reduced` という型でラップして、`reduce` にリダクション処理がすぐに終了するように指示することができます。コレクションの入力を集約し、アキュムレータに10個の要素が入ったらすぐに終了させるリダクションの例を見てみましょう。

[source, clojure]
----
(reduce (fn [acc input]
          (if (= (count acc) 10)
            (reduced acc)
            (conj acc input)))
         []
         (range 100))
;; => [0 1 2 3 4 5 6 7 8 9]
----

トランスデューサは還元関数の修正であるため、早期終了のために `reduced` も使用します。 ステートフルなトランスデューサは、プロセスが終了する前に何らかのクリーンアップを行う必要があるかもしれないことに注意してください。したがって、「補完」ステップとして引数の数が1の場合をサポートしなければなりません。通常、引数の数が0の場合と同様に、この引数の数は単純に変換された還元関数の引数の数が1の場合に委ねられます。

これを知っていれば、 `take` のようなステートフルなトランスデューサを書くことができます。これまでに見た入力の数を追跡するために、内部的にmutable stateを使用し、十分な数の要素を見たらすぐにアキュムレータを `reduced` でラップすることになります。

[source, clojure]
----
(defn my-take
  [n]
  (fn [rfn]
    (let [remaining (volatile! n)]
      (fn
        ([] (rfn))
        ([acc] (rfn acc))
        ([acc input]
          (let [rem @remaining
                nr (vswap! remaining dec)
                result (if (pos? rem)
                         (rfn acc input)   ;; we still have items to take
                         acc)]             ;; we're done, acc becomes the result
            (if (not (pos? nr))
              (ensure-reduced result)      ;; wrap result in reduced if not already
              result)))))))
----

これは、ClojureScriptコアに存在する `take` 関数の簡略化したものです。ここでは注意すべき点がいくつかありますので、理解を深めるために分割して説明します。

まず最初に気づくことは、トランスデューサの中にミュータブルな値を作成していることです。変換するための還元関数を受け取るまではそれを作成していないことに注意してください。もしトランスデューサを返す前に作成していたら、 `my-take` を何度も使うことはできません。トランスデューサは使用されるたびに変換するための還元関数が渡されるので、複数回使用することができ、使用するたびに変異可能な変数が作成されます。

[source, clojure]
----
(fn [rfn]
  (let [remaining (volatile! n)] ;; make sure to create mutable variables inside the transducer
    (fn
      ;; ...
)))

(def take-five (my-take 5))

(transduce take-five conj (range 100))
;; => [0 1 2 3 4]

(transduce take-five conj (range 100))
;; => [0 1 2 3 4]
----

それでは、 `my-take` から返される還元関数を見てみましょう。まず最初に volatile を `deref` して、取るべき要素の数を取得し、それをデクリメントして次の残りの値を取得します。 取るべき項目が残っていれば、アキュムレータと入力を渡して `rfn` を呼び出します。そうでなければ、すでに最終的な結果が出ています。

[source, clojure]
----
([acc input]
  (let [rem @remaining
        nr (vswap! remaining dec)
        result (if (pos? rem)
                 (rfn acc input)
                 acc)]
    ;; ...
))
----

`my-take` の本体はもう明らかでしょう。次の残り（ `nr` ）を使って処理すべき項目がまだあるかどうかをチェックし、ない場合は `ensure-reduced` 関数を使って結果を `reduced` で囲みます。 `ensure-reduced` は、値がまだ還元されていなければ `reduced` で囲み、すでに還元されていれば単に値を返します。まだ終わっていない場合には、さらなる処理のために累積した `result` を返します。

[source, clojure]
----
(if (not (pos? nr))
  (ensure-reduced result)
  result)
----

ステートフルなトランスデューサの例を見てきましたが、完了ステップでは何もしていませんでした。ここでは、完了ステップを使用して累積値をフラッシュするトランスデューサの例を見てみましょう。ここでは， `n` 個の要素が与えられたときに，入力を `n` 個のサイズのベクトルに変換する `partition-all` の簡易版を実装します．目的をよりよく理解するために，数値とコレクションを与えたときに，引数の数が2つのバージョンがどのような結果になるかを見てみましょう．

[source, clojure]
----
(partition-all 3 (range 10))
;; => ((0 1 2) (3 4 5) (6 7 8) (9))
----

`partition-all` のトランスデューサを返す関数は，数 `n` を受け取り，入力をサイズ `n` のベクトルにグループ化するトランスデューサを返します．補完ステップでは，累積した結果があるかどうかをチェックし，あればそれを結果に追加します．ここでは、ClojureScriptのコアである `partition-all` 関数の簡略化したバージョンを紹介します。ここで、 `array-list` は変更可能なJavaScript配列のラッパーです。

[source, clojure]
----
(defn my-partition-all
  [n]
  (fn [rfn]
    (let [a (array-list)]
      (fn
        ([] (rfn))
        ([result]
          (let [result (if (.isEmpty a)                  ;; no inputs accumulated, don't have to modify result
                         result
                         (let [v (vec (.toArray a))]
                           (.clear a)                    ;; flush array contents for garbage collection
                           (unreduced (rfn result v))))] ;; pass to `rfn`, removing the reduced wrapper if present
            (rfn result)))
        ([acc input]
          (.add a input)
          (if (== n (.size a))                           ;; got enough results for a chunk
            (let [v (vec (.toArray a))]
              (.clear a)
              (rfn acc v))                               ;; the accumulated chunk becomes input to `rfn`
            acc))))))

(def triples (my-partition-all 3))

(transduce triples conj (range 10))
;; => [[0 1 2] [3 4 5] [6 7 8] [9]]
----


==== Eductions

エダクションは、コレクションと1つまたは複数の変換を組み合わせる方法で、reduceして反復することができ、それをするたびに変換を適用します。処理したいコレクションと、それに対する変換を他の人に拡張してもらいたい場合、ソースのコレクションと変換をカプセル化したエダクションを渡すことができます。エダクションを作成するには、`eduction`という関数を使います。

[source, clojure]
----
(def ed (eduction (filter odd?) (take 5) (range 100)))

(reduce + 0 ed)
;; => 25

(transduce (partition-all 2) conj ed)
;; => [[1 3] [5 7] [9]]
----


==== More transducers in ClojureScript core

`map` , `filter` , `mapcat` , `take` , `partition-all` について学びましたが、ClojureScriptで利用できるトランスデューサは他にもたくさんあります。ここでは、いくつかの興味深いトランスデューサの不完全なリストを紹介します。

- `drop` は `take` の双子で、最大 `n` 個の値をドロップしてから還元関数に入力を渡します。
- `distinct` は入力を一度だけ許可する。
- `dedupe` は，入力値の連続した重複を除去します．

他にどのようなトランスデューサがあるのか、ClojureScriptコアを調べてみることをお勧めします。


==== Defining our own transducers

独自のトランスデューサを作成する前に考慮すべき点がいくつかありますので、このセクションではトランスデューサを適切に実装する方法を学びます。まず、トランスデューサの一般的な構造は以下のようになっていることを学びました。

[source, clojure]
----
(fn [xf]
  (fn
    ([]          ;; init
      ...)
    ([r]         ;; completion(補完)
      ...)
    ([acc input] ;; step
      ...)))
----

通常，トランスデューサによって変わるのは，`...`で表されるコードだけですが，結果として得られる関数の各アリティで保存されなければならない不変量は以下の通りです。

 * arity 0 (init): 入れ子になった変換 `xf` のarity 0を呼び出さなければなりません。
 * arity 1 (completion): 最終的な値を生成し、状態(state)掃き出す可能性があるため、入れ子の変換 `xf` の arity 1 を *正確に1回* 呼び出さなければなりません。
 * arity 2 (step): 結果として得られる還元関数で、入れ子になった変換 `xf` の arity 2 を0回、1回、または複数回呼び出す必要があります。


==== Transducible processes

変換可能なプロセスとは、入力値を取り込む一連のステップで定義されるプロセスのことである。 入力のソースはプロセスごとに異なります。ほとんどの例では、コレクションや遅延シーケンスからの入力を扱っていましたが、非同期の値のストリームや、 `core.async` のチャネルでもよいでしょう。 `into` はトランスデューサのすべての出力を集めたコレクションを作成し、 `sequence` は遅延シーケンスを生成し、非同期ストリームはおそらく出力をリスナーにプッシュするでしょう。

伝達可能なプロセスについての理解を深めるために、束縛されないキューを実装することにします。
なぜなら、キューに値を追加することは、入力を取り込む一連のステップのように考えることができるからです。まず最初に、unbounded queueを実装するためのプロトコルとデータ型を定義します。

[source, clojure]
----
(defprotocol Queue
  (put! [q item] "put an item into the queue")
  (take! [q] "take an item from the queue")
  (shutdown! [q] "stop accepting puts in the queue"))

(deftype UnboundedQueue [^:mutable arr ^:mutable closed]
  Queue
  (put! [_ item]
    (assert (not closed))
    (assert (not (nil? item)))
    (.push arr item)
    item)
  (take! [_]
    (aget (.splice arr 0 1) 0))
  (shutdown! [_]
    (set! closed true)))
----

キュー（Queue）プロトコルを定義しましたが、お気づきかもしれませんが、 `UnboundedQueue` の実装はトランスデューサを全く知りません。これはステップ関数として `put!` オペレーションを持っていて、私たちはそのインターフェイスの上にトランスデューシング・プロセスを実装しようとしています。

[source, clojure]
----
(defn unbounded-queue
  ([]
   (unbounded-queue nil))
  ([xform]
   (let [put! (completing put!)
         xput! (if xform (xform put!) put!)
         q (UnboundedQueue. #js [] false)]
     (reify
       Queue
       (put! [_ item]
         (when-not (.-closed q)
           (let [val (xput! q item)]
             (if (reduced? val)
               (do
                 (xput! @val)  ;; call completion step
                 (shutdown! q) ;; respect reduced
                 @val)
               val))))
       (take! [_]
         (take! q))
       (shutdown! [_]
         (shutdown! q))))))
----

ご覧の通り、`unbounded-queue`コンストラクタは内部で`UnboundedQueue`インスタンスを使用しており、`take!`と`shutdown!`の呼び出しを代りに行い、`put!`関数でトランスデューシブル・プロセス・ロジックを実装しています。何が起こっているのか理解するために、分解してみましょう。

[source, clojure]
----
(let [put! (completing put!)
      xput! (if xform (xform put!) put!)
      q (UnboundedQueue. #js [] false)]
  ;; ...
)
----

まず、 `Queue` プロトコルの `put!` 関数にアリティ0とアリティ1を追加するために `completing` を使用しています。 これにより、この還元関数を `xform` に渡して別の関数を派生させる場合に、トランスデューサとうまく連携することができます。その後、トランスデューサ（ `xform` ）が渡された場合には、そのトランスデューサを適用した還元関数を `put!` に導きます。 トランスデューサが渡されていない場合は，単に `put!` を使用します． `q` は `UnboundedQueue` の内部インスタンスです。

[source, clojure]
----
(reify
  Queue
  (put! [_ item]
    (when-not (.-closed q)
      (let [val (xput! q item)]
        (if (reduced? val)
          (do
            (xput! @val)  ;; call completion step
            (shutdown! q) ;; respect reduced
            @val)
          val))))
  ;; ...
)
----

公開された `put!` 操作は、キューがシャットダウンされていない場合にのみ実行されます。 `UnboundedQueue` の `put!` 実装では、まだ値を入れることができるかどうかを検証するためにアサートを使用しており、この不変性を破りたくないことに注意してください。キューが閉じていなければ値を入れることができ、そのために変換された可能性のある `xput!` を使用します。

put操作でreduceされた値が返ってきた場合、それはトランスデューシブル・プロセスを終了させるべきだということを示しています。 この場合、それはキューをシャットダウンして、それ以上の値を受け入れないようにすることを意味します。reduceされた値を得られなかった場合は、喜んでプットを受け入れ続けることができます。

それでは、トランスデューサなしでキューがどのように動作するか見てみましょう。

[source, clojure]
----
(def q (unbounded-queue))
;; => #<[object Object]>

(put! q 1)
;; => 1
(put! q 2)
;; => 2

(take! q)
;; => 1
(take! q)
;; => 2
(take! q)
;; => nil
----

期待通りの結果が得られましたが、今度はステートレスなトランスデューサで試してみましょう。

[source, clojure]
----
(def incq (unbounded-queue (map inc)))
;; => #<[object Object]>

(put! incq 1)
;; => 2
(put! incq 2)
;; => 3

(take! incq)
;; => 2
(take! incq)
;; => 3
(take! incq)
;; => nil
----

トランスデューシブル・プロセスを実装したことを確認するために、ステートフルなトランスデューサを使用してみましょう。ここでは、4と等しくない値を受け入れ、入力を2要素のチャンクに分割するトランスデューサを使用します。

[source, clojure]
----
(def xq (unbounded-queue (comp
                           (take-while #(not= % 4))
                           (partition-all 2))))

(put! xq 1)
(put! xq 2)
;; => [1 2]
(put! xq 3)
(put! xq 4) ;; shouldn't accept more values from here on
(put! xq 5)
;; => nil

(take! xq)
;; => [1 2]
(take! xq) ;; seems like `partition-all` flushed correctly!
;; => [3]
(take! xq)
;; => nil
----

キューの例は、 `core.async` チャンネルが内部ステップでトランスデューサを使用する方法に大きく影響を受けています。チャネルとそのトランスデューサの使い方については、後のセクションで説明します。

トランスデューシブル・プロセスは、早期終了を知らせる方法として、 `reduced` を尊重しなければなりません。例えば、コレクションの構築は `reduced` に遭遇すると停止し、トランスデューサを持つ `core.async` チャネルは閉じられます。 `reduced` の値は `deref` でアンラップして補完ステップに渡さなければなりません。補完ステップは正確に一度だけ呼ばれなければなりません。

トランスデューサを自分のステップ関数で呼び出したときに生成される還元関数は、ステートフルで他の場所から使用するのは安全ではない可能性があるので、トランスデューサプロセスは公開すべきではありません。

[[transients]]
=== Transients

ClojureScriptの不変で永続的なデータ構造はそれなりの性能を持っていますが、大きなデータ構造を複数のステップを使って変換し、最終的な結果だけを共有するような状況があります。たとえば、コアの `into` 関数は、コレクションを受け取り、シーケンスのコンテンツでそれを熱心に入力します。

[source, clojure]
----
(into [] (range 100))
;; => [0 1 2 ... 98 99]
----

上の例では，100 個の要素を一度に `conj` したベクトルを生成しています．最終結果ではないすべての中間ベクトルは、 `into` 関数以外の誰にも見えませんし、永続化に必要な配列のコピーは不要なオーバーヘッドです。

このような状況のために、ClojureScriptはいくつかの永続的なデータ構造の特別なバージョンを提供しています。マップ、ベクター、セットにはトランジェントの対応物があります。 トランジェントは、一定時間でトランジェントバージョンを作成する `transient` 関数を使用して、常に永続的なデータ構造から派生します。

[source, clojure]
----
(def tv (transient [1 2 3]))
;; => #<[object Object]>
----

トランジェントは、永続的なリードAPIをサポートしています。

[source, clojure]
----
(def tv (transient [1 2 3]))

(nth tv 0)
;; => 1

(get tv 2)
;; => 3

(def tm (transient {:language "ClojureScript"}))

(:language tm)
;; => "ClojureScript"

(def ts (transient #{:a :b :c}))

(contains? ts :a)
;; => true

(:a ts)
;; => :a
----

トランシェントは、更新のための永続的で不変的なセマンティクスを持っていないので、すでにおなじみの `conj` や `assoc` 関数を使って変換することはできません。その代わり、トランジェントで動作する変換関数は、最後に大きな音を立てて終了します。トランジェントに `conj!` を使った例を見てみましょう。

[source, clojure]
----
(def tv (transient [1 2 3]))

(conj! tv 4)
;; => #<[object Object]>

(nth tv 3)
;; => 4
----

ご覧のように、過渡的バージョンのベクターは、不変でも永続的でもありません。代わりに、ベクターはその場で変異します。 `tv` に対して `conj!` を使って繰り返し変換することはできますが、永続的なデータ構造で使われるイディオムを放棄すべきではありません：過渡的に変換するときは、次の例のように、返されたバージョンをさらに修正するために使います。

[source, clojure]
----
(-> [1 2 3]
  transient
  (conj! 4)
  (conj! 5))
;; => #<[object Object]>
----

トランジェントを永続的で不変的なデータ構造に戻すには、トランジェントに対して `persistent!` を呼び出します。この操作は、永続的なデータ構造からトランジェントを導き出すのと同様に、一定時間で行われます。

[source, clojure]
----
(-> [1 2 3]
  transient
  (conj! 4)
  (conj! 5)
  persistent!)
;; => [1 2 3 4 5]
----

トランジェントを永続的な構造に変換する際の特徴は、トランジェントバージョンが永続的なデータ構造に変換された後に無効になり、それ以上の変換ができなくなることです。これは、派生した永続的データ構造がトランジェントの内部ノードを使用しており、それらを変異させると不変性と永続性の保証が破られるために起こります。

[source, clojure]
----
(def tm (transient {}))
;; => #<[object Object]>

(assoc! tm :foo :bar)
;; => #<[object Object]>

(persistent! tm)
;; => {:foo :bar}

(assoc! tm :baz :frob)
;; Error: assoc! after persistent!
----

最初に紹介した `into` の例に戻ります。 これは、パフォーマンスのためにトランジェントを使用し、永続的なデータ構造を返すもので、内部的には変異を使用していますが、純粋に機能的なインターフェイスを公開しています。

[source, clojure]
----
(defn my-into
  [to from]
  (persistent! (reduce conj! (transient to) from)))

(my-into [] (range 100))
;; => [0 1 2 ... 98 99]
----


[[metadata-section]]
=== Metadata

ClojureScriptのシンボル、var、永続的なコレクションは、メタデータの添付をサポートしています。メタデータとは、それが添付されているエンティティに関する情報を持つマップのことです。ClojureScriptコンパイラは、タイプヒントなどの目的でメタデータを使用します。また、メタデータシステムは、ツール、ライブラリ、アプリケーションの開発者も使用できます。

日常的なClojureScriptのプログラミングでは、メタデータを必要とするケースはあまりないかもしれませんが、メタデータは知っておくと便利な言語機能です。メタデータがあると、ランタイムコードのイントロスペクションやドキュメントの生成などが非常に簡単になります。このセクションでは、その理由を説明します。


==== Vars

varを定義して、デフォルトでどのようなメタデータが付加されているか見てみましょう。このコードは REPL で実行されるので、ソースファイルで定義された var のメタデータは異なる可能性があることに注意してください。ここでは、 `meta` 関数を使って、与えられた値のメタデータを取得します。

[source, clojure]
----
(def answer-to-everything 42)
;; => 42

#'answer-to-everything
;; => #'cljs.user/answer-to-everyhing

(meta #'answer-to-everything)
;; => {:ns cljs.user,
;;     :name answer-to-everything,
;;     :file "NO_SOURCE_FILE",
;;     :source "answer-to-everything",
;;     :column 6,
;;     :end-column 26,
;;     :line 1,
;;     :end-line 1,
;;     :arglists (),
;;     :doc nil,
;;     :test nil}
----

ここで注意すべき点がいくつかあります。まず、 `#'answer-to-everything` は、 `answer-to-everything` シンボルの値を保持する `Var` への参照を与えます。その中には、定義された名前空間( `:ns` )、その名前、ファイル(ただし、REPLで定義されているので、ソースファイルはありません)、ソース、定義されたファイル内の位置、引数リスト(これは関数にしか意味がありません)、ドキュメント文字列、テスト関数の情報が含まれていることがわかります。

それでは、関数varのメタデータを見てみましょう。

[source, clojure]
----
(defn add
  "A function that adds two numbers."
  [x y]
  (+ x y))

(meta #'add)
;; => {:ns cljs.user,
;;     :name add,
;;     :file "NO_SOURCE_FILE",
;;     :source "add",
;;     :column 7,
;;     :end-column 10,
;;     :line 1,
;;     :end-line 1,
;;     :arglists (quote ([x y])),
;;     :doc "A function that adds two numbers.",
;;     :test nil}
----

引数リストは var のメタデータの `:arglists` フィールドに、ドキュメントは `:doc` フィールドに格納されていることがわかります。それでは、`:test` が何に使われているのかを学ぶために、テスト関数を定義してみましょう。

[source, clojure]
----
(require '[cljs.test :as t])

(t/deftest i-pass
  (t/is true))

(meta #'i-pass)
;; => {:ns cljs.user,
;;     :name i-pass,
;;     :file "NO_SOURCE_FILE",
;;     :source "i-pass",
;;     :column 12,
;;     :end-column 18,
;;     :line 1,
;;     :end-line 1,
;;     :arglists (),
;;     :doc "A function that adds two numbers.",
;;     :test #<function (){ ... }>}
----

`i-pass` 変数のメタデータにある `:test` 属性 (簡潔にするために切り捨てられています) は、テスト関数です。これは `cljs.test` ライブラリが、指示された名前空間でテストを発見して実行するために使用されます。


==== Values

VARはメタデータを持つことができ、どのような種類のメタデータがコンパイラやテストライブラリ `cljs.test` によって消費されるために追加されるかを学びました。永続的なコレクションもメタデータを持つことができますが、デフォルトでは何も持っていません。 `with-meta` 関数を使って、同じ値、同じ型で、与えられたメタデータが付加されたオブジェクトを派生させることができます。その方法を見てみましょう。

[source, clojure]
----
(def map-without-metadata {:language "ClojureScript"})
;; => {:language "ClojureScript"}

(meta map-without-metadata)
;; => nil

(def map-with-metadata (with-meta map-without-metadata
                                  {:answer-to-everything 42}))
;; => {:language "ClojureScript"}

(meta map-with-metadata)
;; => {:answer-to-everything 42}

(= map-with-metadata
   map-without-metadata)
;; => true

(identical? map-with-metadata
            map-without-metadata)
;; => false
----

ClojureScriptの等価性は値に基づいているので、メタデータが2つのデータ構造間の等価性に影響を与えないことは驚くべきことではありません。もう一つの興味深い点は、 `with-meta` は、与えられたものと同じ型と値の別のオブジェクトを作成し、与えられたメタデータをそれに添付することです。

もうひとつの未解決の問題は、永続的なデータ構造から新しい値を導き出すとき、メタデータはどうなるのかということです。 それを調べてみましょう。

[source, clojure]
----
(def derived-map (assoc map-with-metadata :language "Clojure"))
;; => {:language "Clojure"}

(meta derived-map)
;; => {:answer-to-everything 42}
----

上の例でわかるように、メタデータは永続的なデータ構造の派生バージョンで保存されます。しかし、いくつかの微妙な点があります。新しいデータ構造を派生させる関数が同じ型のコレクションを返す限り、メタデータは保存されますが、変換によって型が変わった場合はそうはなりません。この点を説明するために、ベクターからseqやサブベクターを派生させるとどうなるかを見てみましょう。

[source, clojure]
----
(def v (with-meta [0 1 2 3] {:foo :bar}))
;; => [0 1 2 3]

(def sv (subvec v 0 2))
;; => [0 1]

(meta sv)
;; => nil

(meta (seq v))
;; => nil
----


==== Syntax for metadata

ClojureScriptリーダーは、メタデータアノテーションの構文をサポートしており、さまざまな方法で記述することができます。var定義やコレクションの前にキャレット（ `^` ）を付け、その後にマップを付ければ、与えられたメタデータ・マップでアノテーションすることができます。

[source, clojure]
----
(def ^{:doc "The answer to Life, Universe and Everything."} answer-to-everything 42)
;; => 42

(meta #'answer-to-everything)
;; => {:ns cljs.user,
;;     :name answer-to-everything,
;;     :file "NO_SOURCE_FILE",
;;     :source "answer-to-everything",
;;     :column 6,
;;     :end-column 26,
;;     :line 1,
;;     :end-line 1,
;;     :arglists (),
;;     :doc "The answer to Life, Universe and Everything.",
;;     :test nil}

(def map-with-metadata ^{:answer-to-everything 42} {:language "ClojureScript"})
;; => {:language "ClojureScript"}

(meta map-with-metadata)
;; => {:answer-to-everything 42}
----

answer-to-everything`のvar定義で与えられたメタデータが、varのメタデータにマージされていることに注目してください。

メタデータの非常に一般的な使い方は、特定のキーを `true` の値に設定することです。たとえば、varのメタデータに、その変数が動的であることや定数であることを追加したい場合があります。このような場合には、キャレットの後にキーワードを続けて使用する略記法があります。以下にその例を示します。

[source, clojure]
----
(def ^:dynamic *foo* 42)
;; => 42

(:dynamic (meta #'*foo*))
;; => true

(def ^:foo ^:bar answer 42)
;; => 42

(select-keys (meta #'answer) [:foo :bar])
;; => {:foo true, :bar true}
----

メタデータを付加するために、もう一つの略記法があります。キャレットの後にシンボルを使用すると、それはメタデータマップの `:tag` キーの下に追加されます。 `^boolean` のようなタグを使うことで、ClojureScriptコンパイラに式や関数の戻り値の型に関するヒントを与えることができます。

[source, clojure]
----
(defn ^boolean will-it-blend? [_] true)
;; => #<function ... >

(:tag (meta #'will-it-blend?))
;; => boolean

(not ^boolean (js/isNaN js/NaN))
;; => false
----

==== Functions for working with metadata

これまで、 `meta` と `with-meta` について学んできましたが、ClojureScriptにはメタデータを変換するための関数がいくつかあります。 `vary-meta` は、元のオブジェクトと同じ型と値を持つ新しいオブジェクトを派生させるという点で、 `with-meta` と似ていますが、メタデータを直接添付することはありません。その代わりに、与えられたオブジェクトのメタデータに適用する関数を受け取り、新しいメタデータを導出するために変換します。このような仕組みになっています。

[source, clojure]
----
(def map-with-metadata ^{:foo 40} {:language "ClojureScript"})
;; => {:language "ClojureScript"}

(meta map-with-metadata)
;; => {:foo 40}

(def derived-map (vary-meta map-with-metadata update :foo + 2))
;; => {:language "ClojureScript"}

(meta derived-map)
;; => {:foo 42}
----

代わりに既存のvarやvalueのメタデータを変更したい場合は、関数を適用して変更する場合は `alter-meta!` を、別のマップで置き換える場合は `reset-meta!` を使用します。

[source, clojure]
----
(def map-with-metadata ^{:foo 40} {:language "ClojureScript"})
;; => {:language "ClojureScript"}

(meta map-with-metadata)
;; => {:foo 40}

(alter-meta! map-with-metadata update :foo + 2)
;; => {:foo 42}

(meta map-with-metadata)
;; => {:foo 42}

(reset-meta! map-with-metadata {:foo 40})
;; => {:foo 40}

(meta map-with-metadata)
;; => {:foo 40}
----


////
TODO: metadata on functions and multiarity functions
////


[[core-protocols-section]]
=== Core protocols

ClojureScriptのコア関数の最大の特徴の1つは、プロトコルに基づいて実装されていることです。これにより、我々が定義したものであれ、サードパーティが定義したものであれ、そのようなプロトコルで拡張されたあらゆる型で動作するようになっています。


==== Functions

これまでの章で学んだように、関数以外にも呼び出すことができます。ベクトルはそのインデックスの関数，マップはそのキーの関数，セットはその値の関数です．

型を拡張して，`IFn` プロトコルを実装した関数として呼び出すことができます．関数として呼び出すことをサポートしていないコレクションにキューがありますが、 `PersistentQueue` 型に `IFn` を実装して、インデックスの関数としてキューを呼び出せるようにしましょう。

[source, clojure]
----
(extend-type PersistentQueue
  IFn
  (-invoke
    ([this idx]
      (nth this idx))))

(def q #queue[:a :b :c])
;; => #queue [:a :b :c]

(q 0)
;; => :a

(q 1)
;; => :b

(q 2)
;; => :c
----


==== Printing

////
TODO: IWriter?
////

いくつかのコアなプロトコルを学ぶために、値のペアを保持する `Pair` 型を定義します。

[source, clojure]
----
(deftype Pair [fst snd])
----

型の表示方法をカスタマイズしたい場合には、 `IPrintWithWriter` プロトコルを実装することができます。 `pr-writer` という関数が定義されていて、表示する値、ライターオブジェクト、オプションを受け取ります。この関数はライターオブジェクトの `-write` 関数を使用して、目的の `Pair` 文字列表現を書き込みます。


[source, clojure]
----
(extend-type Pair
  IPrintWithWriter
  (-pr-writer [p writer _]
    (-write writer (str "#<Pair " (.-fst p) "," (.-snd p) ">"))))
----


==== Sequences

xref:the-sequence-abstraction[前のセクション]では、ClojureScriptの主要な抽象化の1つであるシーケンスについて学びました。シーケンスを扱うための `first` と `rest` という関数を覚えていますか？これらは `ISeq` プロトコルで定義されているので、このような関数に応答する型を拡張することができます。

[source, clojure]
----
(extend-type Pair
  ISeq
  (-first [p]
    (.-fst p))

  (-rest [p]
    (list (.-snd p))))

(def p (Pair. 1 2))
;; => #<Pair 1,2>

(first p)
;; => 1

(rest p)
;; => (2)
----

シーケンスを扱うのに便利なもう一つの関数が `next` です。 `next` は、与えられた引数がシーケンスである限り動作しますが、`INext` プロトコルを用いて明示的に実装することができます。

[source, clojure]
----
(def p (Pair. 1 2))

(next p)
;; => (2)

(extend-type Pair
  INext
  (-next [p]
    (println "Our next")
    (list (.-snd p))))

(next p)
;; Our next
;; => (2)
----

最後に、 `ISeqable` プロトコルを実装して、独自の型をseqableにすることができます。つまり、それらを `seq` に渡して、シーケンスを返すことができるのです。

ISeqable
[source, clojure]
----
(def p (Pair. 1 2))

(extend-type Pair
  ISeqable
  (-seq [p]
    (list (.-fst p) (.-snd p))))

(seq p)
;; => (1 2)
----

これで、 `Pair` 型は、シーケンスを扱うための豊富なClojureScript関数で動作するようになりました。

[source, clojure]
----
(def p (Pair. 1 2))
;; => #<Pair 1,2>

(map inc p)
;; => (2 3)

(filter odd? p)
;; => (1)

(reduce + p)
;; => 3
----


==== Collections

コレクション関数は、プロトコルの観点からも定義されています。このセクションの例では、JavaScriptのネイティブな文字列をコレクションのように動作させます。

コレクションを扱う上で最も重要な関数は `ICollection` プロトコルで定義された `conj` です。 文字列は、文字列に `conj` することに意味がある唯一の型であり、文字列に対する `conj` 操作は単純に連結になります。

[source, clojure]
----
(extend-type string
  ICollection
  (-conj [this o]
    (str this o)))

(conj "foo" "bar")
;; => "foobar"

(conj "foo" "bar" "baz")
;; => "foobarbaz"
----

コレクションを扱う際に便利なもう1つの関数が `empty` で、これは `IEmptyableCollection` プロトコルの一部です。これを文字列型に実装してみましょう。

[source, clojure]
----
(extend-type string
  IEmptyableCollection
  (-empty [_]
    ""))

(empty "foo")
;; => ""
----

ここでは、JavaScriptのネイティブな文字列を拡張するために、 `string` という特殊記号を使用しました。もっと詳しく知りたい方は、xref:extending-javascript-types[JavaScriptの型を拡張することについての章]をご覧ください。


===== Collection traits

すべてのコレクションが持っているわけではない性質があります。例えば、一定時間で数えられることや、可逆的であることなどです。これらの特性は、すべてのコレクションで意味があるわけではないので、異なるプロトコルに分割されます。これらのプロトコルを説明するために、先に定義した `Pair` 型を使用します。

`ICounted` プロトコルは、 `count` 関数を用いて一定時間内に数えることができるコレクションに対して実装することができます。これを `Pair` 型に実装するのは簡単なはずです。

[source, clojure]
----
(extend-type Pair
  ICounted
  (-count [_]
    2))

(def p (Pair. 1 2))

(count p)
;; => 2
----

ベクトルやリストなどのコレクション型の中には， `nth` 関数を用いて数値によるインデックスを作成できるものがあります．インデックス付きの型であれば、 `IIndexed` プロトコルを実装することができます。

[source, clojure]
----
(extend-type Pair
  IIndexed
  (-nth
    ([p idx]
      (case idx
        0 (.-fst p)
        1 (.-snd p)
        (throw (js/Error. "Index out of bounds"))))
    ([p idx default]
      (case idx
        0 (.-fst p)
        1 (.-snd p)
        default))))

(nth p 0)
;; => 1

(nth p 1)
;; => 2

(nth p 2)
;; Error: Index out of bounds

(nth p 2 :default)
;; => :default
----

////
TODO: ISorted?
////

////
TODO: IReversible?
////


==== Associative

データ構造の中には，キーと値を対応させる「連想」を利用したものがたくさんあります．すでにいくつかのデータ構造を見てきましたし、 `get` 、 `assoc` 、 `dissoc` など、これらのデータ構造を扱う関数もたくさん知っています。これらの関数の基礎となるプロトコルを調べてみましょう。

まず最初に，連想データ構造のキーを検索する方法が必要です． `ILookup` プロトコルはそのための関数を定義しています。ここでは、インデックス0と1を値にマッピングする連想データ構造である `Pair` 型のキーを検索する機能を追加してみましょう。

[source, clojure]
----
(extend-type Pair
  ILookup
  (-lookup
    ([p k]
      (-lookup p k nil))
    ([p k default]
      (case k
        0 (.-fst p)
        1 (.-snd p)
        default))))

(get p 0)
;; => 1

(get p 1)
;; => 2

(get p :foo)
;; => nil

(get p 2 :default)
;; => :default
----

データ構造で `assoc` を使用するには、`IAssociative` プロトコルを実装する必要があります。我々の `Pair` 型では，値を関連付けるためのキーとして0と1のみが許可されます．また， `IAssociative` には，キーが存在するかどうかを問い合わせる機能があります．

[source, clojure]
----
(extend-type Pair
  IAssociative
  (-contains-key? [_ k]
    (contains? #{0 1} k))

  (-assoc [p k v]
    (case k
      0 (Pair. v (.-snd p))
      1 (Pair. (.-fst p) v)
      (throw (js/Error. "Can only assoc to 0 and 1 keys")))))

(def p (Pair. 1 2))
;; => #<Pair 1,2>

(assoc p 0 2)
;; => #<Pair 2,2>

(assoc p 1 1)
;; => #<Pair 1,1>

(assoc p 0 0 1 1)
;; => #<Pair 0,1>

(assoc p 2 3)
;; Error: Can only assoc to 0 and 1 keys
----

`assoc` を補完する関数は `dissoc` で、 `IMap` プロトコルの一部です。私たちの `Pair` 型にはあまり意味がありませんが、それでも実装してみましょう。0や1をdissocさせると、その位置に `nil` を置くことになり、無効なキーは無視されます。

[source, clojure]
----
(extend-type Pair
  IMap
  (-dissoc [p k]
    (case k
      0 (Pair. nil (.-snd p))
      1 (Pair. (.-fst p) nil)
      p)))

(def p (Pair. 1 2))
;; => #<Pair 1,2>

(dissoc p 0)
;; => #<Pair ,2>

(dissoc p 1)
;; => #<Pair 1,>

(dissoc p 2)
;; => #<Pair 1,2>

(dissoc p 0 1)
;; => #<Pair ,>
----

連想データ構造は、エントリと呼ばれるキーと値のペアで構成されます。関数 `key` と `val` は、このようなエントリのキーと値を問い合わせることができ、`IMapEntry` プロトコルに基づいて構築されています。 `key` と `val` のいくつかの例と、マップエントリを使ってどのようにマップを構築するかを見てみましょう。

[source, clojure]
----
(key [:foo :bar])
;; => :foo

(val [:foo :bar])
;; => :bar

(into {} [[:foo :bar] [:baz :xyz]])
;; => {:foo :bar, :baz :xyz}
----

Pairもマップエントリになりますが、その場合は最初の要素をキー、2番目の要素を値として扱います。

[source, clojure]
----
(extend-type Pair
  IMapEntry
  (-key [p]
    (.-fst p))

  (-val [p]
    (.-snd p)))

(def p (Pair. 1 2))
;; => #<Pair 1,2>

(key p)
;; => 1

(val p)
;; => 2

(into {} [p])
;; => {1 2}
----


==== Comparison

For checking whether two or more values are equivalent with `=` we must implement the `IEquiv` protocol. Let's do it for our `Pair` type:

[source, clojure]
----
(def p  (Pair. 1 2))
(def p' (Pair. 1 2))
(def p'' (Pair. 1 2))

(= p p')
;; => false

(= p p' p'')
;; => false

(extend-type Pair
  IEquiv
  (-equiv [p other]
    (and (instance? Pair other)
         (= (.-fst p) (.-fst other))
         (= (.-snd p) (.-snd other)))))

(= p p')
;; => true

(= p p' p'')
;; => true
----

////
TODO: IHash?
////

We can also make types comparable. The function `compare` takes two values and returns a negative number if the first is less than the second, 0 if both are equal and 1 if the first is greater than the second. For making our types comparable we must implement the `IComparable` protocol.

For pairs, comparison will mean checking if the two first values are equal. If they are, the result will be the comparison of the second values. If not, we will return the result of the first comparison:

[source, clojure]
----
(extend-type Pair
  IComparable
  (-compare [p other]
    (let [fc (compare (.-fst p) (.-fst other))]
      (if (zero? fc)
        (compare (.-snd p) (.-snd other))
        fc))))

(compare (Pair. 0 1) (Pair. 0 1))
;; => 0

(compare (Pair. 0 1) (Pair. 0 2))
;; => -1

(compare (Pair. 1 1) (Pair. 0 2))
;; => 1

(sort [(Pair. 1 1) (Pair. 0 2) (Pair. 0 1)])
;; => (#<Pair 0,1> #<Pair 0,2> #<Pair 1,1>)
----


==== Metadata

The `meta` and `with-meta` functions are also based upon two protocols: `IMeta` and `IWithMeta` respectively.  We can make our own types capable of carrying metadata adding an extra field for holding the metadata and implementing both protocols.

Let's implement a version of `Pair` that can have metadata:

[source, clojure]
----
(deftype Pair [fst snd meta]
  IMeta
  (-meta [p] meta)

  IWithMeta
  (-with-meta [p new-meta]
    (Pair. fst snd new-meta)))


(def p (Pair. 1 2 {:foo :bar}))
;; => #<Pair 1,2>

(meta p)
;; => {:foo :bar}

(def p' (with-meta p {:bar :baz}))
;; => #<Pair 1,2>

(meta p')
;; => {:bar :baz}
----


==== Interoperability with JavaScript


Since ClojureScript is hosted in a JavaScript VM we often need to convert ClojureScript data structures to JavaScript ones and viceversa. We also may want to make native JS types participate in an abstraction represented by a protocol.


[[extending-javascript-types]]
===== Extending JavaScript types

When extending JavaScript objects instead of using JS globals like `js/String`, `js/Date` and such, special symbols are used. This is done for avoiding mutating global JS objects.

The symbols for extending JS types are: `object`, `array`, `number`, `string`, `function`, `boolean` and `nil` is used for the null object. The dispatch of the protocol to native objects uses Google Closure's link:https://google.github.io/closure-library/api/namespace_goog.html#typeOf[goog.typeOf] function. There's a special `default` symbol that can be used for making a default implementation of a protocol for every type.

For illustrating the extension of JS types we are going to define a `MaybeMutable` protocol that'll have a `mutable?` predicate as its only function. Since in JavaScript mutability is the default we'll extend the default JS type returning true from `mutable?`:

[source, clojure]
----
(defprotocol MaybeMutable
  (mutable? [this] "Returns true if the value is mutable."))

(extend-type default
  MaybeMutable
  (mutable? [_] true))

;; object
(mutable? #js {})
;; => true

;; array
(mutable? #js [])
;; => true

;; string
(mutable? "")
;; => true

;; function
(mutable? (fn [x] x))
;; => true
----

Since fortunately not all JS object's values are mutable we can refine the implementation of `MaybeMutable` for returning `false` for strings and functions.

[source, clojure]
----
(extend-protocol MaybeMutable
  string
  (mutable? [_] false)

  function
  (mutable? [_] false))


;; object
(mutable? #js {})
;; => true

;; array
(mutable? #js [])
;; => true

;; string
(mutable? "")
;; => false

;; function
(mutable? (fn [x] x))
;; => false
----

There is no special symbol for JavaScript dates so we have to extend `js/Date` directly. The same applies to the rest of the types found in the global `js` namespace.


===== Converting data

For converting values from ClojureScript types to JavaScript ones and viceversa we use the `clj->js` and `js->clj` functions, which are based in the `IEncodeJS` and `IEncodeClojure` protocols respectively.

For the examples we'll use the Set type introduced in ES6. Note that is not available in every JS runtime.


====== From ClojureScript to JS

First of all we'll extend ClojureScript's set type for being able to convert it to JS. By default sets are converted to JavaScript arrays:

[source, clojure]
----
(clj->js #{1 2 3})
;; => #js [1 3 2]
----

Let's fix it, `clj->js` is supposed to convert values recursively so we'll make sure to convert all the set contents to JS and creating the set with the converted values:

[source, clojure]
----
(extend-type PersistentHashSet
  IEncodeJS
  (-clj->js [s]
    (js/Set. (into-array (map clj->js s)))))

(def s (clj->js #{1 2 3}))
(es6-iterator-seq (.values s))
;; => (1 3 2)

(instance? js/Set s)
;; => true

(.has s 1)
;; => true
(.has s 2)
;; => true
(.has s 3)
;; => true
(.has s 4)
;; => false
----

The `es6-iterator-seq` is an experimental function in ClojureScript core for obtaining a seq from an ES6 iterable.


====== From JS to ClojureScript


Now it's time to extend the JS set to convert to ClojureScript. As with `clj->js`, `js->clj` recursively converts the value of the data structure:

[source, clojure]
----
(extend-type js/Set
  IEncodeClojure
  (-js->clj [s options]
    (into #{} (map js->clj (es6-iterator-seq (.values s))))))

(= #{1 2 3}
   (js->clj (clj->js #{1 2 3})))
;; => true

(= #{[1 2 3] [4 5] [6]}
   (js->clj (clj->js #{[1 2 3] [4 5] [6]})))
;; => true
----

Note that there is no one-to-one mapping between ClojureScript and JavaScript values. For example, ClojureScript keywords are converted to JavaScript strings when passed to `clj->js`.


==== Reductions

The `reduce` function is based on the `IReduce` protocol, which enables us to make our own or third-party types reducible. Apart from using them with `reduce` they will automatically work with `transduce` too, which will allow us to make a reduction with a transducer.

The JS array is already reducible in ClojureScript:

[source, clojure]
----
(reduce + #js [1 2 3])
;; => 6

(transduce (map inc) conj [] [1 2 3])
;; => [2 3 4]
----

However, the new ES6 Set type isn't so let's implement the `IReduce` protocol. We'll get an iterator using the Set's `values` method and convert it to a seq with the `es6-iterator-seq` function; after that we'll delegate to the original `reduce` function to reduce the obtained sequence.

[source, clojure]
----
(extend-type js/Set
  IReduce
  (-reduce
   ([s f]
     (let [it (.values s)]
       (reduce f (es6-iterator-seq it))))
   ([s f init]
     (let [it (.values s)]
       (reduce f init (es6-iterator-seq it))))))

(reduce + (js/Set. #js [1 2 3]))
;; => 6

(transduce (map inc) conj [] (js/Set. #js [1 2 3]))
;; => [2 3 4]
----

Associative data structures can be reduced with the `reduce-kv` function, which is based in the `IKVReduce` protocol. The main difference between `reduce` and `reduce-kv` is that the latter uses a three-argument function as a reducer, receiving the accumulator, key and value for each item.

Let's look at an example, we will reduce a map to a vector of pairs. Note that, since vectors associate indexes to values, they can also be reduced with `reduce-kv`.

[source, clojure]
----
(reduce-kv (fn [acc k v]
             (conj acc [k v]))
           []
           {:foo :bar
            :baz :xyz})
;; => [[:foo :bar] [:baz :xyz]]
----

We'll extend the new ES6 map type to support `reduce-kv`, we'll do this by getting a sequence of key-value pairs and calling the reducing function with the accumulator, key and value as positional arguments:

[source, clojure]
----
(extend-type js/Map
  IKVReduce
  (-kv-reduce [m f init]
   (let [it (.entries m)]
     (reduce (fn [acc [k v]]
               (f acc k v))
             init
             (es6-iterator-seq it)))))

(def m (js/Map.))
(.set m "foo" "bar")
(.set m "baz" "xyz")

(reduce-kv (fn [acc k v]
             (conj acc [k v]))
           []
           m)
;; => [["foo" "bar"] ["baz" "xyz"]]
----

In both examples we ended up delegating to the `reduce` function, which is aware of reduced values and terminates when encountering one. Take into account that if you don't implement these protocols in terms of `reduce` you will have to check for reduced values for early termination.


==== Delayed computation

There are some types that have the notion of asynchronous computation, the value they represent may not be realized yet. We can ask whether a value is realized using the `realized?` predicate.

Let's ilustrate it with the `Delay` type, which takes a computation and executes it when the result is needed.  When we dereference a delay the computation is run and the delay is realized:

[source, clojure]
----
(defn computation []
  (println "running!")
  42)

(def d (delay (computation)))

(realized? d)
;; => false

(deref d)
;; running!
;; => 42

(realized? d)
;; => true

@d
;; => 42
----

Both `realized?` and `deref` sit atop two protocols: `IPending` and `IDeref`.


==== State

The ClojureScript state constructs such as the Atom and the Volatile have different characteristics and semantics, and the operations on them like `add-watch`, `reset!` or `swap!` are backed by protocols.


===== Atom

For ilustrating such protocols we will implement our own simplified version of an `Atom`. It won't support validators nor metadata, but we will be able to:

- `deref` the atom for getting its current value
- `reset!` the value contained in the atom
- `swap!` the atom with a function for transforming its state

`deref` is based on the `IDeref` protocol. `reset!` is based on the `IReset` protocol and `swap!` on `ISwap`. We'll start by defining a data type and a constructor for our atom implementation:

[source, clojure]
----
(deftype MyAtom [^:mutable state ^:mutable watches]
  IPrintWithWriter
  (-pr-writer [p writer _]
    (-write writer (str "#<MyAtom " (pr-str state) ">"))))

(defn my-atom
  ([]
    (my-atom nil))
  ([init]
    (MyAtom. init {})))

(my-atom)
;; => #<MyAtom nil>

(my-atom 42)
;; => #<MyAtom 42>
----

Note that we've marked both the current state of the atom (`state`) and the map of watchers (`watches`) with the `{:mutable true}` metadata. We'll be modifying them and we're making this explicit with the annotations.

Our `MyAtom` type is not very useful yet, we'll start by implementing the `IDeref` protocol so we can dereference its current value:

[source, clojure]
----
(extend-type MyAtom
  IDeref
  (-deref [a]
    (.-state a)))

(def a (my-atom 42))

@a
;; => 42
----

Now that we can dereference it we'll implement the `IWatchable` protocol, which will let us add and remove watches to our custom atom. We'll store the watches in the `watches` map of `MyAtom`, associating keys to callbacks.

[source, clojure]
----
(extend-type MyAtom
  IWatchable
  (-add-watch [a key f]
    (let [ws (.-watches a)]
      (set! (.-watches a) (assoc ws key f))))

  (-remove-watch [a key]
    (let [ws (.-watches a)]
      (set! (.-watches a) (dissoc ws key))))

  (-notify-watches [a oldval newval]
    (doseq [[key f] (.-watches a)]
      (f key a oldval newval))))
----

We can now add watches to our atom but is not very useful since we still can't change it. For incorporating change we have to implement the `IReset` protocol and make sure we notify the watches every time we reset the atom's value.

[source, clojure]
----
(extend-type MyAtom
  IReset
  (-reset! [a newval]
    (let [oldval (.-state a)]
      (set! (.-state a) newval)
      (-notify-watches a oldval newval)
      newval)))
----

Now let's check that we got it right. We'll add a watch, change the atom's value making sure the watch gets called and then remove it:

[source, clojure]
----
(def a (my-atom 41))
;; => #<MyAtom 41>

(add-watch a :log (fn [key a oldval newval]
                    (println {:key key
                              :old oldval
                              :new newval})))
;; => #<MyAtom 41>

(reset! a 42)
;; {:key :log, :old 41, :new 42}
;; => 42

(remove-watch a :log)
;; => #<MyAtom 42>

(reset! a 43)
;; => 43
----

Our atom is still missing the swapping functionality so we'll add that now, let's implement the `ISwap` protocol. There are four arities for the `-swap!` method of the protocol since the function passed to `swap!` may take one, two, three or more arguments:


[source, clojure]
----
(extend-type MyAtom
  ISwap
  (-swap!
   ([a f]
    (let [oldval (.-state a)
          newval (f oldval)]
      (reset! a newval)))

   ([a f x]
     (let [oldval (.-state a)
           newval (f oldval x)]
       (reset! a newval)))

   ([a f x y]
     (let [oldval (.-state a)
           newval (f oldval x y)]
       (reset! a newval)))

   ([a f x y more]
     (let [oldval (.-state a)
           newval (apply f oldval x y more)]
       (reset! a newval)))))
----

We now have a custom implementation of the atom abstraction, let's test it in the REPL and see if it behaves like we expect:

[source, clojure]
----
(def a (my-atom 0))
;; => #<MyAtom 0>

(add-watch a :log (fn [key a oldval newval]
                    (println {:key key
                              :old oldval
                              :new newval})))
;; => #<MyAtom 0>

(swap! a inc)
;; {:key :log, :old 0, :new 1}
;; => 1

(swap! a + 2)
;; {:key :log, :old 1, :new 3}
;; => 3

(swap! a - 2)
;; {:key :log, :old 3, :new 1}
;; => 1

(swap! a + 2 3)
;; {:key :log, :old 1, :new 6}
;; => 6


(swap! a + 4 5 6)
;; {:key :log, :old 6, :new 21}
;; => 21

(swap! a * 2)
;; {:key :log, :old 21, :new 42}
;; => 42

(remove-watch a :log)
;; => #<MyAtom 42>
----

We did it! We implemented a version of ClojureScript Atom without support for metadata nor validators, extending it to support such features is left as an exercise for the reader. Note that you'll need to modify the `MyAtom` type for being able to store metadata and a validator.


===== Volatile

Volatiles are simpler than atoms in that they don't support watching for changes. All changes override the previous value much like the mutable variables present in almost every programming language. Volatiles are based on the `IVolatile` protocol that only defines a method for `vreset!`, since `vswap!` is implemented as a macro.

Let's start by creating our own volatile type and constructor:

[source, clojure]
----
(deftype MyVolatile [^:mutable state]
  IPrintWithWriter
  (-pr-writer [p writer _]
    (-write writer (str "#<MyVolatile " (pr-str state) ">"))))

(defn my-volatile
  ([]
    (my-volatile nil))
  ([v]
    (MyVolatile. v)))

(my-volatile)
;; => #<MyVolatile nil>

(my-volatile 42)
;; => #<MyVolatile 42>
----

Our `MyVolatile` still needs to support dereferencing and reseting it, let's implement `IDeref` and `IVolatile`, which will enable use to use `deref`, `vreset!` and `vswap!` in our custom volatile:

[source, clojure]
----
(extend-type MyVolatile
  IDeref
  (-deref [v]
    (.-state v))

  IVolatile
  (-vreset! [v newval]
    (set! (.-state v) newval)
    newval))

(def v (my-volatile 0))
;; => #<MyVolatile 42>

(vreset! v 1)
;; => 1

@v
;; => 1

(vswap! v + 2 3)
;; => 6

@v
;; => 6
----


==== Mutation

In the xref:transients[section about transients] we learned about the mutable counterparts of the immutable and persistent data structures that ClojureScript provides. These data structures are mutable, and the operations on them end with a bang (`!`) to make that explicit. As you may have guessed every operation on transients is based on protocols.


===== From persistent to transient and viceversa

We've learned that we can transform a persistent data structure with the `transient` function, which is based on the `IEditableCollection` protocol; for transforming a transient data structure to a persistent one we use `persistent!`, based on `ITransientCollection`.

Implementing immutable and persistent data structures and their transient counterparts is out of the scope of this book but we recommend taking a look at ClojureScript's data structure implementation if you are curious.


===== Transient vectors and sets

We've learned about most of the protocols for transient data structures but we're missing two: `ITransientVector` for using `assoc!` on transient vectors and `ITransientSet` for using `disj!` on transient sets.

For illustrating the `ITransientVector` protocol we'll extend the JavaScript array type for making it an associative transient data structure:

[source, clojure]
----
(extend-type array
  ITransientAssociative
  (-assoc! [arr key val]
    (if (number? key)
      (-assoc-n! arr key val)
      (throw (js/Error. "Array's key for assoc! must be a number."))))

  ITransientVector
  (-assoc-n! [arr n val]
    (.splice arr n 1 val)
    arr))

(def a #js [1 2 3])
;; => #js [1 2 3]

(assoc! a 0 42)
;; => #js [42 2 3]

(assoc! a 1 43)
;; => #js [42 43 3]

(assoc! a 2 44)
;; => #js [42 43 44]
----

For illustrating the `ITransientSet` protocol we'll extend the ES6 Set type for making it a transient set, supporting the `conj!`, `disj!` and `persistent!` operations. Note that we've extended the Set type previously for being able to convert it to ClojureScript and we'll take advantage of that fact.

[source, clojure]
----
(extend-type js/Set
  ITransientCollection
  (-conj! [s v]
    (.add s v)
    s)

  (-persistent! [s]
   (js->clj s))

  ITransientSet
  (-disjoin! [s v]
    (.delete s v)
    s))

(def s (js/Set.))

(conj! s 1)
(conj! s 1)
(conj! s 2)
(conj! s 2)

(persistent! s)
;; => #{1 2}

(disj! s 1)

(persistent! s)
;; => #{2}
----

=== CSP (with core.async)

CSP stands for Communicating Sequential Processes, which is a formalism for describing concurrent systems pioneered by C. A. R. Hoare in 1978. It is a concurrency model based on message passing and synchronization through channels.  An in-depth look at the theoretical model behind CSP is beyond the scope of this book; instead we'll focus on presenting the concurrency primitives that `core.async` offers.

`core.async` is not part of ClojureScript core but it's implemented as a library. Even though it is not part of the core language it's widely used. Many libraries build on top of the `core.async` primitives, so we think it is worth covering in the book. It's also a good example of the syntactic abstractions that can be achieved by transforming code with ClojureScript macros, so we'll jump right in. You'll need to have `core.async` installed to run the examples presented in this section.


==== Channels

Channels are like conveyor belts, we can put and take a single value at a time from them. They can have multiple readers and writers, and they are the fundamental message-passing mechanism of `core.async`. In order to see how it works, we'll create a channel to perform some operations on it.

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! take!]])

(enable-console-print!)

(def ch (chan))

(take! ch #(println "Got a value:" %))
;; => nil

;; there is a now a pending take operation, let's put something on the channel

(put! ch 42)
;; Got a value: 42
;; => 42
----

In the above example we created a channel `ch` using the `chan` constructor.  After that we performed a take operation on the channel, providing a callback that will be invoked when the take operation succeeds. After using `put!` to put a value on the channel the take operation completed and the `"Got a value: 42"` string was printed. Note that `put!` returned the value that was just put to the channel.

The `put!` function accepts a callback like `take!` does but we didn't provide any in the last example. For puts the callback will be called whenever the value we provided has been taken. Puts and takes can happen in any order, let's do a few puts followed by takes to illustrate the point:

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! take!]])

(def ch (chan))

(put! ch 42 #(println "Just put 42"))
;; => true
(put! ch 43 #(println "Just put 43"))
;; => true

(take! ch #(println "Got" %))
;; Got 42
;; Just put 42
;; => nil

(take! ch #(println "Got" %))
;; Got 43
;; Just put 43
;; => nil
----

You may be asking yourself why the `put!` operations return `true`. It signals that the put operation could be performed, even though the value hasn't yet been taken. Channels can be closed, which will cause the put operations to not succeed:

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! close!]])

(def ch (chan))

(close! ch)
;; => nil

(put! ch 42)
;; => false
----

The above example was the simplest possible situation but what happens with pending operations when a channel is closed? Let's do a few takes and close the channel and see what happens:

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! take! close!]])

(def ch (chan))

(take! ch #(println "Got value:" %))
;; => nil
(take! ch #(println "Got value:" %))
;; => nil

(close! ch)
;; Got value: nil
;; Got value: nil
;; => nil
----

We see that if the channel is closed all the `take!` operations receive a `nil` value. `nil` in channels is a sentinel value that signals to takers that the channel has been closed. Because of that, putting a `nil` value on a channel is not allowed:

[source, clojure]
----
(require '[cljs.core.async :refer [chan put!]])

(def ch (chan))

(put! ch nil)
;; Error: Assert failed: Can't put nil in on a channel
----


===== Buffers

We've seen that pending take and put operations are enqueued in a channel but, what happens when there are many pending take or put operations? Let's find out by hammering a channel with many puts and takes:

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! take!]])

(def ch (chan))

(dotimes [n 1025]
  (put! ch n))
;; Error: Assert failed: No more than 1024 pending puts are allowed on a single channel.

(def ch (chan))

(dotimes [n 1025]
  (take! ch #(println "Got" %)))
;; Error: Assert failed: No more than 1024 pending takes are allowed on a single channel.
----

As the example above shows there's a limit of pending puts or takes on a channel, it's currently 1024 but that is an implementation detail that may change. Note that there can't be both pending puts and pending takes on a channel since puts will immediately succeed if there are pending takes and viceversa.

Channels support buffering of put operations. If we create a channel with a buffer the put operations will succeed immediately if there's room in the buffer and be enqueued otherwise. Let's illustrate the point creating a channel with a buffer of one element. The `chan` constructors accepts a number as its first argument which will cause it to have a buffer with the given size:

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! take!]])

(def ch (chan 1))

(put! ch 42 #(println "Put succeeded!"))
;; Put succeeded!
;; => true

(dotimes [n 1024]
  (put! ch n))
;; => nil

(put! ch 42)
;; Error: Assert failed: No more than 1024 pending puts are allowed on a single channel.
----

What happened in the example above? We created a channel with a buffer of size 1 and performed a put operation on it that succeeded immediately because the value was buffered. After that we did another 1024 puts to fill the pending put queue and, when trying to put one value more the channel complained about not being able to enqueue more puts.

Now that we know about how channels work and what are buffers used for let's explore the different buffers that `core.async` implements. Different buffers have different policies and it's interesting to know all of them to know when to use what. Channels are unbuffered by default.


====== Fixed

The fixed size buffer is the one that is created when we give the `chan` constructor a number and it will have the size specified by the given number. It is the simplest possible buffer: when full, puts will be enqueued.

The `chan` constructor accepts either a number or a buffer as its first argument. The two channels created in the following example both use a fixed buffer of size 32:

[source, clojure]
----
(require '[cljs.core.async :refer [chan buffer]])

(def a-ch (chan 32))

(def another-ch (chan (buffer 32)))
----


====== Dropping

The fixed buffer allows put operations to be enqueued. However, as we saw before, puts are still queued when the fixed buffer is full. If we wan't to discard the put operations that happen when the buffer is full we can use a dropping buffer.

Dropping buffers have a fixed size and, when they are full puts will complete but their value will be discarded. Let's illustrate the point with an example:

[source, clojure]
----
(require '[cljs.core.async :refer [chan dropping-buffer put! take!]])

(def ch (chan (dropping-buffer 2)))

(put! ch 40)
;; => true
(put! ch 41)
;; => true
(put! ch 42)
;; => true

(take! ch #(println "Got" %))
;; Got 40
;; => nil
(take! ch #(println "Got" %))
;; Got 41
;; => nil
(take! ch #(println "Got" %))
;; => nil
----

We performed three put operations and the three of them succeded but, since the dropping buffer of the channel has size 2, only the first two values were delivered to the takers. As you can observe the third take is enqueued since there is no value available, the third put's value (42) was discarded.


====== Sliding

The sliding buffer has the opposite policy than the dropping buffer. When full puts will complete and the oldest value will be discarded in favor of the new one.  The sliding buffer is useful when we are interested in processing the last puts only and we can afford discarding old values.

[source, clojure]
----
(require '[cljs.core.async :refer [chan sliding-buffer put! take!]])

(def ch (chan (sliding-buffer 2)))

(put! ch 40)
;; => true
(put! ch 41)
;; => true
(put! ch 42)
;; => true

(take! ch #(println "Got" %))
;; Got 41
;; => nil
(take! ch #(println "Got" %))
;; Got 42
;; => nil
(take! ch #(println "Got" %))
;; => nil
----

We performed three put operations and the three of them succeded but, since the sliding buffer of the channel has size 2, only the last two values were delivered to the takers. As you can observe the third take is enqueued since there is no value available since the first put's value was discarded.


===== Transducers

As mentioned in the section about transducers, putting values in a channel can be thought as a transducible process. This means that we can create channels and hand them a transducer, giving us the ability to transform the input values before being put in the channel.

If we want to use a transducer with a channel we must supply a buffer since the reducing function that will be modified by the transducer will be the buffer's add function. A buffer's add function is a reducing function since it takes a buffer and an input and returns a buffer with such input incorporated.

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! take!]])

(def ch (chan 1 (map inc)))

(put! ch 41)
;; => true

(take! ch #(println "Got" %))
;; Got 42
;; => nil
----

You may be wondering what happens to a channel when the reducing function returns a reduced value. It turns out that the notion of termination for channels is being closed, so channels will be closed when a reduced value is encountered:

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! take!]])

(def ch (chan 1 (take 2)))

(take! ch #(println "Got" %))
;; => nil
(take! ch #(println "Got" %))
;; => nil
(take! ch #(println "Got" %))
;; => nil

(put! ch 41)
;; => true
(put! ch 42)
;; Got 41
;; => true
(put! ch 43)
;; Got 42
;; Got nil
;; => false
----

We used the `take` stateful transducer to allow maximum 2 puts into the channel.  We then performed three take operations on the channel and we expect only two to receive a value. As you can see in the above example the third take got the sentinel `nil` value which indicates that the channel was closed. Also, the third put operation returned `false` indicating that it didn't take place.


===== Handling exceptions

If adding a value to a buffer throws an exception `core.async` the operation will fail and the exception will be logged to the console. However, channel constructors accept a third argument: a function for handling exceptions.

When creating a channel with an exception handler it will be called with the exception whenever an exception occurs. If the handler returns `nil` the operation will fail silently and if it returns another value the add operation will be retried with such value.

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! take!]])

(enable-console-print!)

(defn exception-xform
  [rfn]
  (fn [acc input]
    (throw (js/Error. "I fail!"))))

(defn handle-exception
  [ex]
  (println "Exception message:" (.-message ex))
  42)

(def ch (chan 1 exception-xform handle-exception))

(put! ch 0)
;; Exception message: I fail!
;; => true

(take! ch #(println "Got:" %))
;; Got: 42
;; => nil
----

===== Offer and Poll

We've learned about the two basic operations on channels so far: `put!` and `take!`. They either take or put a value and are enqueued if they can't be performed immediately. Both functions are asynchronous because of their nature: they can succeed but be completed at a later time.

`core.async` has two synchronous operations for putting or taking values: `offer!` and `poll!`. Let's see how they work through examples.

`offer!` puts a value in a channel if it's possible to do so immediately. It returns `true` if the channel received the value and `false` otherwise. Note that, unlike with `put!`, `offer!` cannot distinguish between closed and open channels.

[source, clojure]
----
(require '[cljs.core.async :refer [chan offer!]])

(def ch (chan 1))

(offer! ch 42)
;; => true

(offer! ch 43)
;; => false
----

`poll!` takes a value from a channel if it's possible to do so immediately. Returns the value if succesful and `nil` otherwise. Unlike `take!`, `poll!` cannot distinguish closed and open channels.

[source, clojure]
----
(require '[cljs.core.async :refer [chan offer! poll!]])

(def ch (chan 1))

(poll! ch)
;; => nil

(offer! ch 42)
;; => true

(poll! ch)
;; => 42
----


==== Processes

We learned all about channels but there is still a missing piece in the puzzle: processes.  Processes are pieces of logic that run independently and use channels for communication and coordination. Puts and takes inside a process will stop the process until the operation completes. Stopping a process doesn't block the only thread we have in the environments where ClojureScript runs. Instead, it will be resumed at a later time when the operation is waiting for being performed.

Processes are launched using the `go` macro and puts and takes use the `<!` and `>!` placeholders. The `go` macro rewrites your code to use callbacks but inside `go` everything looks like synchronous code, which makes understanding it straightforward:

[source, clojure]
----
(require '[cljs.core.async :refer [chan <! >!]])
(require-macros '[cljs.core.async.macros :refer [go]])

(enable-console-print!)

(def ch (chan))

(go
  (println [:a] "Gonna take from channel")
  (println [:a] "Got" (<! ch)))

(go
  (println [:b] "Gonna put on channel")
  (>! ch 42)
  (println [:b] "Just put 42"))

;; [:a] Gonna take from channel
;; [:b] Gonna put on channel
;; [:b] Just put 42
;; [:a] Got 42
----

In the above example we are launching a process with `go` that takes a value from `ch` and prints it to the console. Since the value isn't immediately available it will park until it can resume. After that we launch another process that puts a value on the channel.

Since there is a pending take the put operation succeeds and the value is delivered to the first process, then both processes terminate.

Both `go` blocks run independently and, even though they are executed asynchronously, they look like synchronous code. The above go blocks are fairly simple but being able to write concurrent processes that coordinate via channels is a very powerful tool for implementing complex asynchronous workflows. Channels also offer a great decoupling of producers and consumers.

Processes can wait for an arbitrary amount of time too, there is a `timeout` function that return a channel that will be closed after the given amount of miliseconds. Combining a timeout channel with a take operation inside a go block gives us the ability to sleep:

[source, clojure]
----
(require '[cljs.core.async :refer [<! timeout]])
(require-macros '[cljs.core.async.macros :refer [go]])

(enable-console-print!)

(defn seconds
  []
  (.getSeconds (js/Date.)))

(println "Launching go block")

(go
  (println [:a] "Gonna take a nap" (seconds))
  (<! (timeout 1000))
  (println [:a] "I slept one second, bye!" (seconds)))

(println "Block launched")

;; Launching go block
;; Block launched
;; [:a] Gonna take a nap 9
;; [:a] I slept one second, bye! 10
----

As we can see in the messages printed, the process does nothing for one second when it blocks in the take operation of the timeout channel. The program continues and after one second the process resumes and terminates.


===== Choice

Apart from putting and taking one value at a time inside a go block we can also make a non-deterministic choice on multiple channel operations using `alts!`.  `alts!` is given a series of channel put or take operations (note that we can also try to put and take in a channel at the same time) and only performs one as soon as is ready; if multiple operations can be performed when calling `alts!` it will do a pseudo random choice by default.

We can easily try an operation on a channel and cancel it after a certain amount of time combining the `timeout` function and `alts!`. Let's see how:

[source, clojure]
----
(require '[cljs.core.async :refer [chan <! timeout alts!]])
(require-macros '[cljs.core.async.macros :refer [go]])

(enable-console-print!)

(def ch (chan))

(go
  (println [:a] "Gonna take a nap")
  (<! (timeout 1000))
  (println [:a] "I slept one second, trying to put a value on channel")
  (>! ch 42)
  (println [:a] "I'm done!"))

(go
  (println [:b] "Gonna try taking from channel")
  (let [cancel (timeout 300)
        [value ch] (alts! [ch cancel])]
    (if (= ch cancel)
      (println [:b] "Too slow, take from channel cancelled")
      (println [:b] "Got" value))))

;; [:a] Gonna take a nap
;; [:b] Gonna try taking from channel
;; [:b] Too slow, take from channel cancelled
;; [:a] I slept one second, trying to put a value on channel
----

In the example above we launched a go block that, after waiting for a second, puts a value in the `ch` channel. The other go block creates a `cancel` channel, which will be closed after 300 miliseconds. After that, it tries to read from both `ch` and `cancel` at the same time using `alts!`, which will succeed whenever it can take a value from either of those channels. Since `cancel` is closed after 300 miliseconds, `alts!` will succeed since takes from closed channel return the `nil` sentinel. Note that `alts!` returns a two-element vector with the returned value of the operation and the channel where it was performed.

This is why we are able to detect whether the read operation was performed in the `cancel` channel or in `ch`. I suggest you copy this example and set the first process timeout to 100 miliseconds to see how the read operation on `ch` succeeds.

We've learned how to choose between read operations so let's look at how to express a conditional write operation in `alts!`. Since we need to provide the channel and a value to try to put on it, we'll use a two element vector with the channel and the value for representing write operations.

Let's see an example:

[source, clojure]
----
(require '[cljs.core.async :refer [chan <! alts!]])
(require-macros '[cljs.core.async.macros :refer [go]])

(enable-console-print!)

(def a-ch (chan))
(def another-ch (chan))

(go
  (println [:a] "Take a value from `a-ch`")
  (println [:a] "Got" (<! a-ch))
  (println [:a] "I'm done!"))

(go
  (println [:b] "Take a value from `another-ch`")
  (println [:a] "Got" (<! another-ch))
  (println [:b] "I'm done!"))

(go
  (println [:c] "Gonna try putting in both channels simultaneously")
  (let [[value ch] (alts! [[a-ch 42]
                           [another-ch 99]])]
    (if (= ch a-ch)
      (println [:c] "Put a value in `a-ch`")
      (println [:c] "Put a value in `another-ch`"))))

;; [:a] Take a value from `a-ch`
;; [:b] Take a value from `another-ch`
;; [:c] Gonna try putting in both channels simultaneously
;; [:c] Put a value in `a-ch`
;; [:a] Got 42
;; [:a] I'm done!
----

When running the above example only the put operation on the `a-ch` channel has succeeded. Since both channels are ready to take a value when the `alts!` occurs you may get different results when running this code.


===== Priority

`alts!` default is to make a non-deterministic choice whenever several operations are ready to be performed. We can instead give priority to the operations passing the `:priority` option to `alts!`. Whenever `:priority` is `true`, if more than one operation is ready they will be tried in order.

[source, clojure]
----
(require '[cljs.core.async :refer [chan >! alts!]])
(require-macros '[cljs.core.async.macros :refer [go]])

(enable-console-print!)

(def a-ch (chan))
(def another-ch (chan))

(go
  (println [:a] "Put a value on `a-ch`")
  (>! a-ch 42)
  (println [:a] "I'm done!"))

(go
  (println [:b] "Put a value on `another-ch`")
  (>! another-ch 99)
  (println [:b] "I'm done!"))

(go
  (println [:c] "Gonna try taking from both channels with priority")
  (let [[value ch] (alts! [a-ch another-ch] :priority true)]
    (if (= ch a-ch)
      (println [:c] "Got" value "from `a-ch`")
      (println [:c] "Got" value "from `another-ch`"))))

;; [:a] Put a value on `a-ch`
;; [:a] I'm done!
;; [:b] Put a value on `another-ch`
;; [:b] I'm done!
;; [:c] Gonna try taking from both channels with priority
;; [:c] Got 42 from `a-ch`
----

Since both `a-ch` and `another-ch` had a value to read when the `alts!` was executed and we set the `:priority` option to true, `a-ch` has preference. You can try deleting the `:priority` option and running the example multiple times to see that, without priority, `alts!` makes a non-deterministic choice.


===== Defaults

Another interesting bit of `alts!` is that it can return immediately if no operation is ready and we provide a default value. We can conditionally do a choice on the operations if and only if any of them is ready, returning a default value if it's not.

[source, clojure]
----
(require '[cljs.core.async :refer [chan alts!]])
(require-macros '[cljs.core.async.macros :refer [go]])

(def a-ch (chan))
(def another-ch (chan))

(go
  (println [:a] "Gonna try taking from any of the channels without blocking")
  (let [[value ch] (alts! [a-ch another-ch] :default :not-ready)]
    (if (and (= value :not-ready)
             (= ch :default))
      (println [:a] "No operation is ready, aborting")
      (println [:a] "Got" value))))

;; [:a] Gonna try taking from any of the channels without blocking
;; [:a] No operation is ready, aborting
----

As you can see in the above example, if no operation is ready the value returned by `alts!` is the one we supplied after the `:default` key when calling it and the channel is the `:default` keyword itself.


==== Combinators

Now that we're acquainted with channels and processes it's time to explore some interesting combinators for working with channels that are present in `core.async`. This section includes a brief description of all of them together with a simple example of their usage.


===== pipe

`pipe` takes an input and output channels and pipes all the values put on the input channel to the output one. The output channel is closed whenever the source is closed unless we provide a `false` third argument:

[source, clojure]
----
(require '[cljs.core.async :refer [chan pipe put! <! close!]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

(def in (chan))
(def out (chan))

(pipe in out)

(go-loop [value (<! out)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Got" value)
      (println [:a] "Waiting for a value")
      (recur (<! out)))))

(put! in 0)
;; => true
(put! in 1)
;; => true
(close! in)

;; [:a] Got 0
;; [:a] Waiting for a value
;; [:a] Got 1
;; [:a] Waiting for a value
;; [:a] I'm done!
----

In the above example we used the `go-loop` macro for reading values recursively until the `out` channel is closed. Notice that when we close the `in` channel the `out` channel is closed too, making the `go-loop` terminate.


===== pipeline-async

`pipeline-async` takes a number for controlling parallelism, an output channel, an asynchronous function and an input channel. The asynchronous function has two arguments: the value put in the input channel and a channel where it should put the result of its asynchronous operation, closing the result channel after finishing. The number controls the number of concurrent go blocks that will be used for calling the asynchronous function with the inputs.

The output channel will receive outputs in an order relative to the input channel, regardless the time each asynchronous function call takes to complete. It has an optional last parameter that controls whether the output channel will be closed when the input channel is closed, which defaults to `true`.

[source, clojure]
----
(require '[cljs.core.async :refer [chan pipeline-async put! <! close!]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

(def in (chan))
(def out (chan))
(def parallelism 3)

(defn wait-and-put [value ch]
  (let [wait (rand-int 1000)]
    (js/setTimeout (fn []
                     (println "Waiting" wait "miliseconds for value" value)
                     (put! ch wait)
                     (close! ch))
                   wait)))

(pipeline-async parallelism out wait-and-put in)

(go-loop [value (<! out)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Got" value)
      (println [:a] "Waiting for a value")
      (recur (<! out)))))

(put! in 1)
(put! in 2)
(put! in 3)
(close! in)

;; Waiting 164 miliseconds for value 3
;; Waiting 304 miliseconds for value 2
;; Waiting 908 miliseconds for value 1
;; [:a] Got 908
;; [:a] Waiting for a value
;; [:a] Got 304
;; [:a] Waiting for a value
;; [:a] Got 164
;; [:a] Waiting for a value
;; [:a] I'm done!
----


===== pipeline

`pipeline` is similar to `pipeline-async` but instead of taking and asynchronous function it takes a transducer instead. The transducer will be applied independently to each input.

[source, clojure]
----
(require '[cljs.core.async :refer [chan pipeline put! <! close!]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

(def in (chan))
(def out (chan))
(def parallelism 3)

(pipeline parallelism out (map inc) in)

(go-loop [value (<! out)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Got" value)
      (println [:a] "Waiting for a value")
      (recur (<! out)))))

(put! in 1)
(put! in 2)
(put! in 3)
(close! in)

;; [:a] Got 2
;; [:a] Waiting for a value
;; [:a] Got 3
;; [:a] Waiting for a value
;; [:a] Got 4
;; [:a] Waiting for a value
;; [:a] I'm done!
----


===== split

`split` takes a predicate and a channel and returns a vector with two channels, the first of which will receive the values for which the predicate is true, the second will receive those for which the predicate is false. We can optionally pass a buffer or number for the channels with the third (true channel) and fourth (false channel) arguments.

[source, clojure]
----
(require '[cljs.core.async :refer [chan split put! <! close!]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

(def in (chan))
(def chans (split even? in))
(def even-ch (first chans))
(def odd-ch (second chans))

(go-loop [value (<! even-ch)]
  (if (nil? value)
    (println [:evens] "I'm done!")
    (do
      (println [:evens] "Got" value)
      (println [:evens] "Waiting for a value")
      (recur (<! even-ch)))))

(go-loop [value (<! odd-ch)]
  (if (nil? value)
    (println [:odds] "I'm done!")
    (do
      (println [:odds] "Got" value)
      (println [:odds] "Waiting for a value")
      (recur (<! odd-ch)))))

(put! in 0)
(put! in 1)
(put! in 2)
(put! in 3)
(close! in)

;; [:evens] Got 0
;; [:evens] Waiting for a value
;; [:odds] Got 1
;; [:odds] Waiting for a value
;; [:odds] Got 3
;; [:odds] Waiting for a value
;; [:evens] Got 2
;; [:evens] Waiting for a value
;; [:evens] I'm done!
;; [:odds] I'm done!
----

===== reduce

`reduce` takes a reducing function, initial value and an input channel. It returns a channel with the result of reducing over all the values put on the input channel before closing it using the given initial value as the seed.

[source, clojure]
----
(require '[cljs.core.async :as async :refer [chan put! <! close!]])
(require-macros '[cljs.core.async.macros :refer [go]])

(def in (chan))

(go
  (println "Result" (<! (async/reduce + (+) in))))

(put! in 0)
(put! in 1)
(put! in 2)
(put! in 3)
(close! in)

;; Result: 6
----

===== onto-chan

`onto-chan` takes a channel and a collection and puts the contents of the collection into the channel. It closes the channel after finishing although it accepts a third argument for specifying if it should close it or not. Let's rewrite the `reduce` example using `onto-chan`:

[source, clojure]
----
(require '[cljs.core.async :as async :refer [chan put! <! close! onto-chan]])
(require-macros '[cljs.core.async.macros :refer [go]])

(def in (chan))

(go
  (println "Result" (<! (async/reduce + (+) in))))

(onto-chan in [0 1 2 3])

;; Result: 6
----


===== to-chan

`to-chan` takes a collection and returns a channel where it will put every value in the collection, closing the channel afterwards.

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! <! close! to-chan]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

(def ch (to-chan (range 3)))

(go-loop [value (<! ch)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Got" value)
      (println [:a] "Waiting for a value")
      (recur (<! ch)))))

;; [:a] Got 0
;; [:a] Waiting for a value
;; [:a] Got 1
;; [:a] Waiting for a value
;; [:a] Got 2
;; [:a] Waiting for a value
;; [:a] I'm done!
----


===== merge

`merge` takes a collection of input channels and returns a channel where it will put every value that is put on the input channels. The returned channel will be closed when all the input channels have been closed. The returned channel will be unbuffered by default but a number or buffer can be provided as the last argument.

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! <! close! merge]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

(def in1 (chan))
(def in2 (chan))
(def in3 (chan))

(def out (merge [in1 in2 in3]))

(go-loop [value (<! out)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Got" value)
      (println [:a] "Waiting for a value")
      (recur (<! out)))))

(put! in1 1)
(close! in1)
(put! in2 2)
(close! in2)
(put! in3 3)
(close! in3)

;; [:a] Got 3
;; [:a] Waiting for a value
;; [:a] Got 2
;; [:a] Waiting for a value
;; [:a] Got 1
;; [:a] Waiting for a value
;; [:a] I'm done!
----


==== Higher-level abstractions

We've learned the about the low-level primitives of `core.async` and the combinators that it offers for working with channels. `core.async` also offers some useful, higher-level abstractions on top of channels that can serve as building blocks for more advanced functionality.


===== Mult

Whenever we have a channel whose values have to be broadcasted to many others, we can use `mult` for creating a multiple of the supplied channel. Once we have a mult, we can attach channels to it using `tap` and dettach them using `untap`. Mults also support removing all tapped channels at once with `untap-all`.

Every value put in the source channel of a mult is broadcasted to all the tapped channels, and all of them must accept it before the next item is broadcasted. For preventing slow takers from blocking the mult's values we must use buffering on the tapped channels judiciously.

Closed tapped channels are removed automatically from the mult. When putting a value in the source channels when there are still no taps such value will be dropped.

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! <! close! timeout mult tap]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

;; Source channel and mult
(def in (chan))
(def m-in (mult in))

;; Sink channels
(def a-ch (chan))
(def another-ch (chan))

;; Taker for `a-ch`
(go-loop [value (<! a-ch)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Got" value)
      (recur (<! a-ch)))))

;; Taker for `another-ch`, which sleeps for 3 seconds between takes
(go-loop [value (<! another-ch)]
  (if (nil? value)
    (println [:b] "I'm done!")
    (do
      (println [:b] "Got" value)
      (println [:b] "Resting 3 seconds")
      (<! (timeout 3000))
      (recur (<! another-ch)))))

;; Tap the two channels to the mult
(tap m-in a-ch)
(tap m-in another-ch)

;; See how the values are delivered to `a-ch` and `another-ch`
(put! in 1)
(put! in 2)

;; [:a] Got 1
;; [:b] Got 1
;; [:b] Resting for 3 seconds
;; [:a] Got 2
;; [:b] Got 2
;; [:b] Resting for 3 seconds
----


===== Pub-sub

After learning about mults you could imagine how to implement a pub-sub abstraction on top of `mult`, `tap` and `untap` but since it's a widely used communication mechanism `core.async` already implements this functionality.

Instead of creating a mult from a source channel, we create a publication with `pub` giving it a channel and a function that will be used for extracting the topic of the messages.

We can subscribe to a publication with `sub`, giving it the publication we want to subscribe to, the topic we are interested in and a channel to put the messages that have the given topic. Note that we can subscribe a channel to multiple topics.

`unsub` can be given a publication, topic and channel for unsubscribing such channel from the topic. `unsub-all` can be given a publication and a topic to unsubscribe every channel from the given topic.

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! <! close! pub sub]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

;; Source channel and publication
(def in (chan))
(def publication (pub in :action))

;; Sink channels
(def a-ch (chan))
(def another-ch (chan))

;; Channel with `:increment` action
(sub publication :increment a-ch)

(go-loop [value (<! a-ch)]
  (if (nil? value)
    (println [:a] "I'm done!")
    (do
      (println [:a] "Increment:" (inc (:value value)))
      (recur (<! a-ch)))))

;; Channel with `:double` action
(sub publication :double another-ch)

(go-loop [value (<! another-ch)]
  (if (nil? value)
    (println [:b] "I'm done!")
    (do
      (println [:b] "Double:" (* 2 (:value value)))
      (recur (<! another-ch)))))

;; See how values are delivered to `a-ch` and `another-ch` depending on their action
(put! in {:action :increment :value 98})
(put! in {:action :double :value 21})

;; [:a] Increment: 99
;; [:b] Double: 42
----


===== Mixer

As we learned in the section about `core.async` combinators, we can use the `merge` function for combining multiple channels into one. When merging multiple channels, every value put in the input channels will end up in the merged channel. However, we may want more finer-grained control over which values put in the input channels end up in the output channel, that's where mixers come in handy.

`core.async` gives us the mixer abstraction, which we can use to combine multiple input channnels into an output channel. The interesting part of the mixer is that we can mute, pause and listen exclusively to certain input channels.

We can create a mixer given an output channel with `mix`. Once we have a mixer we can add input channels into the mix using `admix`, remove it using `unmix` or remove every input channel with `unmix-all`.

For controlling the state of the input channel we use the `toggle` function giving it the mixer and a map from channels to their states. Note that we can add channels to the mix using `toggle`, since the map will be merged with the current state of the mix. The state of a channel is a map which can have the keys `:mute`, `:pause` and `:solo` mapped to a boolean.

Let's see what muting, pausing and soloing channels means:

- A muted input channel means that, while still taking values from it, they won't be forwarded to the output channel. Thus, while a channel is muted, all the values put in it will be discarded.
- A paused input channel means that no values will be taken from it. This means that values put in the channel won't be forwarded to the output channel nor discarded.
- When soloing one or more channels the output channel will only receive the values put in soloed channels. By default non-soloed channels are muted but we can use `solo-mode` to decide between muting or pausing non-soloed channels.

That was a lot of information so let's see an example to improve our understanding. First of all, we'll set up a mixer with an `out` channel and add three input channels to the mix. After that, we'll be printing all the values received on the `out` channel to illustrate the control over input channels:

[source, clojure]
----
(require '[cljs.core.async :refer [chan put! <! close! mix admix
                                   unmix toggle solo-mode]])
(require-macros '[cljs.core.async.macros :refer [go-loop]])

;; Output channel and mixer
(def out (chan))
(def mixer (mix out))

;; Input channels
(def in-1 (chan))
(def in-2 (chan))
(def in-3 (chan))

(admix mixer in-1)
(admix mixer in-2)
(admix mixer in-3)

;; Let's listen to the `out` channel and print what we get from it
(go-loop [value (<! out)]
  (if (nil? value)
    (println [:a] "I'm done")
    (do
      (println [:a] "Got" value)
      (recur (<! out)))))
----

By default, every value put in the input channels will be put in the `out` channel:

[source, clojure]
----
(do
  (put! in-1 1)
  (put! in-2 2)
  (put! in-3 3))

;; [:a] Got 1
;; [:a] Got 2
;; [:a] Got 3
----

Let's pause the `in-2` channel, put a value in every input channel and resume `in-2`:

[source, clojure]
----
(toggle mixer {in-2 {:pause true}})
;; => true

(do
  (put! in-1 1)
  (put! in-2 2)
  (put! in-3 3))

;; [:a] Got 1
;; [:a] Got 3

(toggle mixer {in-2 {:pause false}})

;; [:a] Got 2
----

As you can see in the example above, the values put in the paused channels aren't discarded. For discarding values put in an input channel we have to mute it, let's see an example:

[source, clojure]
----
(toggle mixer {in-2 {:mute true}})
;; => true

(do
  (put! in-1 1)
  (put! in-2 2)  ;; `out` will never get this value since it's discarded
  (put! in-3 3))

;; [:a] Got 1
;; [:a] Got 3

(toggle mixer {in-2 {:mute false}})
----

We put a value `2` in the `in-2` channel and, since the channel was muted at the time, the value is discarded and never put into `out`. Let's look at the third state a channel can be inside a mixer: solo.

As we mentioned before, soloing channels of a mixer implies muting the rest of them by default:

[source, clojure]
----
(toggle mixer {in-1 {:solo true}
               in-2 {:solo true}})
;; => true

(do
  (put! in-1 1)
  (put! in-2 2)
  (put! in-3 3)) ;; `out` will never get this value since it's discarded

;; [:a] Got 1
;; [:a] Got 2

(toggle mixer {in-1 {:solo false}
               in-2 {:solo false}})
----

However, we can set the mode the non-soloed channels will be in while there are soloed channels. Let's set the default non-solo mode to pause instead of the default mute:

[source, clojure]
----
(solo-mode mixer :pause)
;; => true
(toggle mixer {in-1 {:solo true}
               in-2 {:solo true}})
;; => true

(do
  (put! in-1 1)
  (put! in-2 2)
  (put! in-3 3))

;; [:a] Got 1
;; [:a] Got 2

(toggle mixer {in-1 {:solo false}
               in-2 {:solo false}})

;; [:a] Got 3
----
