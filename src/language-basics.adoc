=== First steps with Lisp syntax

1958年にJohn McCarthyによって発明されたLispは、現存する最も古いプログラミング言語の一つです。Lispは方言と呼ばれる多くの派生言語に進化しており、ClojureScriptもその一つです。Lispは独自のデータ構造で書かれたプログラミング言語で、当初は括弧で囲まれたリストでしたが、Clojure(Script)はLispの構文をより多くのデータ構造で進化させ、書くのも読むのもより快適になりました。

ClojureScriptで関数を呼び出すには、最初の位置に関数を持つリストを使います。以下の例では，3つの引数に加算関数を適用している．他の言語と異なり、`+`は演算子ではなく関数であることに注意してください。Lispには演算子はなく、関数しかありません。

[source, clojure]
----
(+ 1 2 3)
;; => 6
----

上の例では、引数 `1`, `2`, `3` に対して、加算関数 `+` を適用しています。ClojureScriptでは、シンボル名に `?`や`-`のような変わった文字をシンボル名に使うことができ、読みやすくなっています。

[source, clojure]
----
(zero? 0)
;; => true
----

関数呼び出しとデータ項目のリストを区別するために、リストを引用符で囲み、評価されないようにすることができます。 引用符で囲まれたリストは、関数呼び出しとしてではなく、データとして扱われます。

[source, clojure]
----
'(+ 1 2 3)
;; => (+ 1 2 3)
----

ClojureScriptでは、その構文にリスト以外のものも使用します。詳細は後ほど説明しますが、ここではローカルバインディングを定義するためのベクター（括弧で囲まれたもの）の使い方の例を示します。

[source, clojure]
----
(let [x 1
      y 2
      z 3]
  (+ x y z))
;; => 6
----

これは、ClojureScriptだけでなく、あらゆるLispを使用するために知っておく必要のある構文のほぼすべてです。また、xref:macros-section[macros]によるコード生成は他のどの言語よりも簡単で、必要に応じて言語を拡張する力が十分にあります。


=== The base data types

ClojureScript言語には、他のプログラミング言語と同様に豊富なデータ型が用意されています。数字、文字列、浮動小数点数など、おなじみのスカラーデータ型が用意されています。そのほかにも、シンボル、キーワード、正規表現、変数、アトム、揮発性物質(volatiles)など、あまり馴染みのないデータ型が多数用意されています。

_ClojureScript_ はホスト言語を採用しており、可能な限りホストが提供する型を使用します。例えば、数字や文字列はそのまま使用され、JavaScriptと同じように動作します。


==== Numbers

_ClojureScript_ では、数字には整数と浮動小数点の両方が含まれます。_ClojureScript_ はJavaScriptにコンパイルされたゲスト言語であることを考慮すると、整数は実際にはJavaScriptのネイティブな浮動小数点であることがわかります。

他の言語と同様に、_ClojureScript_ の数字は以下の方法で表されます。

[source, clojure]
----
23
+23
-100
1.7
-2
33e8
12e-14
3.2e-4
----


==== Keywords

_ClojureScript_ におけるキーワードは、常に自分自身に評価されるオブジェクトです。これらは通常、キーを効率的に表現するために<<maps-section,map data structures>>で使用されます。

[source, clojure]
----
:foobar
:2
:?
----

ご覧のように、キーワードの先頭にはすべて `:` が付いていますが、この文字はリテラル構文の一部に過ぎず、オブジェクトの名前の一部ではありません。

また、`keyword` 関数を呼び出してキーワードを作成することもできます。以下の例で理解できない点や不明な点があっても気にしないでください。<<function-section,functions>>については、後のセクションで説明します。

[source, clojure]
----
(keyword "foo")
;; => :foo
----

===== Namespaced keywords

キーワードの前にダブルコロン `::` を付けると、そのキーワードの前に現在の名前空間の名前が付けられます。 キーワードの名前付けは、等値比較に影響することに注意してください。

[source, clojure]
----
::foo
;; => :cljs.user/foo

(= ::foo :foo)
;; => false
----

また、キーワードリテラルに名前空間を含める方法もあります。これは、他の名前空間のための名前空間キーワードを作成する際に便利です。

[source, clojure]
----
:cljs.unraveled/foo
;; => :cljs.unraveled/foo
----

`keyword` 関数には、最初のパラメータとして名前空間を指定できるarity-2のバリエーションがあります。

[source, clojure]
----
(keyword "cljs.unraveled" "foo")
;; => :cljs.unraveled/foo
----


==== Symbols

_ClojureScript_ のシンボルは、(ご存知の) *キーワード* と非常によく似ています。しかし、シンボルは自分自身に対して評価されるのではなく、シンボルが参照しているものに対して評価されます。

シンボルは数字以外の文字で始まり、英数字、*、+、!、-、_、'、?を含むことができます。

[source, clojure]
----
sample-symbol
othersymbol
f1
my-special-swap!
----

すぐには理解できなくても心配ありません。シンボルはほとんどすべての例で使用されていますので、理解を深めていくことができます。


==== Strings

文字列については、まだ知られていないことを説明することはほとんどありません。_ClojureScript_ では、文字列は他の言語と同じように動作します。しかし、興味深い点として、文字列が不変であることが挙げられます。

この場合、文字列は JavaScript と同じです。

[source, clojure]
----
"An example of a string"
----

_ClojureScript_ における文字列の特異な点の一つは、言語のLisp構文によるものです。

[source, clojure]
----
"This is a multiline
      string in ClojureScript."
----

==== Characters

_ClojureScript_ では、Clojureの文字リテラル構文を使って単一の文字を書くこともできます。

[source, clojure]
----
\a        ; The lowercase a character
\newline  ; The newline character
----

ホスト言語には文字リテラルが含まれていないため、_ClojureScript_ の文字は、舞台裏で一文字のJavaScript文字列に変換されます。


==== Collections

ある言語を説明するためのもう一つの大きなステップは、その言語のコレクションとコレク ションの抽象化を説明することです。_ClojureScript_ もこのルールの例外ではありません。

_ClojureScript_  には多くの種類のコレクションがあります。_ClojureScript_  のコレクションと他の言語のコレクションとの主な違いは、コレクションが永続的で不変であるということです。

これらの(おそらく)未知の概念に進む前に、_ClojureScript_ の既存のコレクションタイプのハイレベルな概要を紹介します。


===== Lists

これは Lisp をベースにした言語では古典的なコレクションタイプです。リストは、_ClojureScript_ では最もシンプルなタイプのコレクションです。リストは他のコレクションを含め、あらゆるタイプのアイテムを含むことができます。

_ClojureScript_ のリストは、カッコで囲まれたアイテムで表現されます。

[source, clojure]
----
'(1 2 3 4 5)
'(:foo :bar 2)
----

ご覧のように、すべてのリストの例では、先頭に `'` という文字が付いています。これは、Lisp系言語のリストは、関数やマクロの呼び出しなどを表現するために使われることが多いからです。その場合、最初の項目は呼び出し可能なものとして評価されるシンボルとし、残りのリスト要素は関数の引数とします。しかし、前述の例では、最初の項目はシンボルではなく、単に項目のリストにしています。

次の例では、リストにシングルクォートマークが付いていない場合と付いている場合の違いを示しています。

[source, clojure]
----
(inc 1)
;; => 2

'(inc 1)
;; => (inc 1)
----

ご覧のように，`(inc 1)` をプレフィックス `'` を付けずに評価すると，`inc` シンボルを *inc* 関数に解決し，`1` を第 1 引数として実行して，`2` という値を返します．

また，`list` 関数を使って明示的にリストを作成することもできます．

[source, clojure]
----
(list 1 2 3 4 5)
;; => (1 2 3 4 5)

(list :foo :bar 2)
;; => (:foo :bar 2)
----

リストには、順番にアクセスしたり、最初の要素にアクセスする場合は非常に効率的ですが、要素にランダム（インデックス）にアクセスする必要がある場合は、リストはあまり良い選択肢ではありません。


===== Vectors

リストと同様、*vector* は一連の値を格納しますが、リストが順番に評価されるのに対し、*vector* はその要素に非常に効率的なインデックスアクセスを行います。心配しないでください。次のセクションでは詳細を説明しますが、現時点では、この簡単な説明で十分です。

ベクトルのリテラル構文には角括弧が使われていますが，いくつかの例を見てみましょう．

[source, clojure]
----
[:foo :bar]
[3 4 5 nil]
----

リストと同様に、ベクターも任意の型のオブジェクトを含むことができますが、これは前述の例でわかります。

また、`vector` 関数を使って明示的にベクターを作成することもできますが、ClojureScriptプログラムではあまり使われません。

[source, clojure]
----
(vector 1 2 3)
;; => [1 2 3]

(vector "blah" 3.5 nil)
;; => ["blah" 3.5 nil]
----


[[maps-section]]
===== Maps

マップは、キーと値のペアを格納することができるコレクションの抽象化です。他の言語では、この種の構造は一般的にハッシュマップやディクショナリー（辞書）として知られています。_ClojureScript_ のマップリテラルは、中括弧でペアを挟んで書きます。

[source, clojure]
----
{:foo "bar", :baz 2}
{:alphabet [:a :b :c]}
----

注: カンマはキーと値のペアを区切るためによく使われますが、完全に任意です。_ClojureScript_ の構文では、カンマはスペースのように扱われます。

ベクターのように、マップリテラルの各項目は結果がマップに格納される前に評価されますが、評価の順番は保証されていません。


===== Sets

そして最後に、*セット* です。

セットは、任意のタイプの0個以上のユニークなアイテムを格納し、順序付けされていません。マップと同様、リテラルの構文には中括弧を使用しますが、違いは先頭の文字に `#` を使用することです。また、`set` 関数を使って、コレクションをセットに変換することもできます。

[source, clojure]
----
#{1 2 3 :foo :bar}
;; => #{1 :bar 3 :foo 2}
(set [1 2 1 3 1 4 1 5])
;; => #{1 2 3 4 5}
----

この後のセクションでは、セットやその他のコレクションタイプについて詳しく説明します。


=== Vars

_ClojureScript_ は、不変性に重点を置いた関数型言語です。そのため、他の多くのプログラミング言語で知られているような変数の概念はありません。変数に最も近いものは、代数学で定義する変数です。数学で「x = 6」と言うとき、それは「x」という記号が6という数字を表すことを意味しています。

_ClojureScript_ では、変数はシンボルで表され、1つの値をメタデータと一緒に格納します。

varを定義するには、`def` という特殊な形式を使います。

[source, clojure]
----
(def x 22)
(def y [1 2 3])
----

変数は常に名前空間（<<namespace-section,これについては後で説明します>>）のトップレベルにあります。関数呼び出しの中で `def` を使用すると、var は名前空間レベルで定義されますが、これはお勧めできません。代わりに、`let` を使用して関数内で変数を定義してください。


[[function-section]]
=== Functions

==== The first contact

物事を実現するための時間です。_ClojureScript_  には、ファーストクラス関数と呼ばれるものがあります。これらは他の型と同じように動作します。パラメータとして渡したり、値として返したりすることができ、常にレキシカル・スコープを尊重します。_ClojureScript_  には動的スコープの機能もありますが、これについては別のセクションで説明します。

スコープについてもっと知りたい方は、こちら link:http://en.wikipedia.org/wiki/Scope_(computer_science)[Wikipediaの記事] が非常に充実しており、様々なタイプのスコープについて説明されています。

_ClojureScript_  はLispの方言なので、関数を呼び出す際にはプレフィックス記法を使用します。

[source, clojure]
----
(inc 1)
;; => 2
----

上の例では、`inc` は関数であり、_ClojureScript_ ランタイムの一部であり、`1` は `inc` 関数の最初の引数です。

[source, clojure]
----
(+ 1 2 3)
;; => 6
----

記号 `+` は `add` 関数を表します。ALGOL系の言語では、`+` は演算子であり、2つのパラメータしか使用できませんが、`+` は複数のパラメータを使用できます。

プレフィックス記法には大きな利点がありますが、その中には必ずしも明らかではないものもあります。_ClojureScript_ では、関数と演算子を区別せず、すべてが関数です。直近の利点としては、プレフィックス記法では「演算子」ごとに任意の数の引数を取ることができます。また、演算子の優先順位の問題も完全に解消されます。


==== Defining your own functions

特別な形式である `fn` を使って，名前のない（無名の）関数を定義することができます．これは関数定義の一種です。次の例では，この関数は2つのパラメータを受け取り，その平均値を返します。
 
[source, clojure]
----
(fn [param1 param2]
  (/ (+ param1 param2) 2.0))
----

関数を定義すると同時に、その関数を呼び出すことができます（1つの式の中で）。

[source, clojure]
----
((fn [x] (* x x)) 5)
;; => 25
----

それでは早速、名前付き関数を作ってみましょう。しかし、_named function_ とは実際には何を意味するのでしょうか？非常に簡単です。_ClojureScript_ では、関数はファーストクラスであり、他の値と同じように振る舞います。そのため、関数の名前を付けるには、単に関数をシンボルにバインドするだけです。

[source, clojure]
----
(def square (fn [x] (* x x)))

(square 12)
;; => 144
----

_ClojureScript_ では、関数定義をよりイディオム的にするためのちょっとした構文シュガーとして、 `defn` マクロも提供しています。

[source, clojure]
----
(defn square
  "Return the square of a given number."
  [x]
  (* x x))
----

関数名とパラメータベクトルの間にある文字列を _docstring_ （ドキュメント文字列）と呼びます。ソースファイルからWebドキュメントを自動作成するプログラムでは、このdocstringを使用します。


==== Functions with multiple arities

_ClojureScript_ には、任意の数の引数を持つ関数を定義する機能もあります。構文は通常の関数を定義するのとほぼ同じですが、ボディが複数あるという違いがあります。

例を見てみると、もっとよくわかると思います。

[source, clojure]
----
(defn myinc
  "Self defined version of parameterized `inc`."
  ([x] (myinc x 1))
  ([x increment]
   (+ x increment)))
----

この行： `([x] (myinc x 1))` は、引数が1つしかない場合、その引数と数字の `1` を第2引数として関数 `myinc` を呼び出すことを示しています。もう一方の関数本体 `([x increment] (+ x increment))`  は，引数が2つある場合に，それらを足した結果を返すというものである。

先に定義したマルチアリティ関数を使った例をいくつか紹介します。誤った数の引数で関数を呼び出した場合、コンパイラはエラーメッセージを発することに注意してください。

[source, clojure]
----
(myinc 1)
;; => 2

(myinc 1 3)
;; => 4

(myinc 1 3 3)
;; Compiler error
----

注：「アリティ」の概念を説明することは本書の範囲外ですが、こちらの link:http://en.wikipedia.org/wiki/Arity[Wikipediaの記事] で説明されています。

==== Variadic functions

複数のパラメータを受け付けるもう一つの方法は、可変長の関数を定義することです。可変長の関数とは、任意の数の引数を受け付ける関数です。

[source, clojure]
----
(defn my-variadic-set
  [& params]
  (set params))

(my-variadic-set 1 2 3 1)
;; => #{1 2 3}
----

可変長の関数を表すには、引数のベクトルに `&` シンボルのプレフィックスを使用します。


==== Short syntax for anonymous functions

_ClojureScript_ では、 `#()` リーダーマクロを使って無名関数を定義するための短い構文を提供しています (通常はワンライナーになります)。リーダーマクロは「特別な」式で、コンパイル時に適切な言語形式に変換されます。この場合は、`fn` という特別な形式を使った式に変換されます。

[source, clojure]
----
(def average #(/ (+ %1 %2) 2))

(average 3 4)
;; => 3.5
----

前述の定義は、以下のような略語です。

[source,clojure]
----
(def average-longer (fn [a b] (/ (+ a b) 2)))

(average-longer 7 8)
;; => 7.5
----

`%1` , `%2` ... `N` は、リーダーマクロが解釈されて `fn` 式に変換されるときに暗黙のうちに宣言されるパラメータの位置を示す単純な目印です。

例えば，数値を2乗する関数：`#(* %1 %1))` は，`++#++(* % %))` と書くことができます。

さらに，この構文は，`%&` 記号を用いた可変長の形式もサポートしています。

[source, clojure]
----
(def my-variadic-set #(set %&))

(my-variadic-set 1 2 2)
;; => #{1 2}
----


=== Flow control

_ClojureScript_ は、JavaScriptやCなどの言語とはフローコントロールのアプローチが大きく異なります。


==== Branching with `if`

まずは基本的なものから始めましょう: `if` です。_ClojureScript_ では、`if` は文ではなく式であり、3つのパラメータを持ちます。1つ目は条件式、2つ目は条件式が論理的に真と評価された場合に評価される式、3つ目はそうでない場合に評価される式です。

[source, clojure]
----
(defn discount
  "You get 5% discount for ordering 100 or more items"
  [quantity]
  (if (>= quantity 100)
    0.05
    0))

(discount 30)
;; => 0

(discount 130)
;; => 0.05
----

ブロック式の `do` を使うと，`if` の分岐に複数の式を入れることができます． xref:block-section[`do` については次のセクションで説明します]．


==== Branching with `cond`

`if` 式は、複数の条件を追加するための「else if」の部分がないので、やや制限がある場合があります。そこで登場するのが `cond` マクロです。

`cond` 式では、複数の条件を定義することができます。

[source, clojure]
----
(defn mypos?
  [x]
  (cond
    (> x 0) "positive"
    (< x 0) "negative"
    :else "zero"))

(mypos? 0)
;; => "zero"

(mypos? -2)
;; => "negative"
----

また、 `cond` には `condp` という形式があり、これは単純な `cond` とよく似た動作をしますが、条件（述語とも呼ばれる）がすべての条件で同じである場合には、よりすっきりした印象を与えます。

[source, clojure]
----
(defn translate-lang-code
  [code]
  (condp = (keyword code)
    :es "Spanish"
    :en "English"
    "Unknown"))

(translate-lang-code "en")
;; => "English"

(translate-lang-code "fr")
;; => "Unknown"
----

`condp = (keyword code)` という行は、次の各行において、_ClojureScript_ が `(keyword code)` を評価した結果に `=` 関数を適用することを意味します。


==== Branching with `case`

`case` の分岐式は、先ほどの `condp` の例と似たような使い方をします。主な違いは、`case` は常に `=` 述語/関数を使用することと、分岐値がコンパイル時に評価されることです。この結果、`cond` や `condp` よりもパフォーマンスが高くなりますが、条件値が静的でなければならないというデメリットがあります。

以下は、先ほどの例を `case` を使うように書き直したものです。

[source, clojure]
----
(defn translate-lang-code
  [code]
  (case code
    "es" "Spanish"
    "en" "English"
    "Unknown"))

(translate-lang-code "en")
;; => "English"

(translate-lang-code "fr")
;; => "Unknown"
----


[[truthiness-section]]
=== Truthiness

これは、各言語が独自のセマンティクスを持っている側面です（ほとんどが間違っています）。大多数の言語は、空のコレクションや整数の0などを偽とみなします。 _ClojureScript_ では、他の言語とは異なり、`nil` と `false` の2つの値だけが偽とみなされます。それ以外はすべて論理的な `true` として扱われます。

呼び出し可能なプロトコル（後で詳しく説明する `IFn` ）を実装する能力と合わせて、セットのようなデータ構造は、関数で追加のラッピングをすることなく、述語として使用することができます。

[source, clojure]
----
(def valid? #{1 2 3})

(filter valid? (range 1 10))
;; => (1 2 3)
----

セットは、含まれるすべての要素の値そのものを返すか、`nil` を返すので、これは機能します。

[source, clojure]
----
(valid? 1)
;; => 1

(valid? 4)
;; => nil
----


=== Locals, Blocks, and Loops

==== Locals

_ClojureScript_ には、ALGOL的な言語のような変数の概念はありませんが、局所があります。局所は通常通り不変であり、変更しようとするとコンパイラがエラーを出します。

局所は `let` 式で定義されます。この式では，最初のパラメータとしてベクターを指定し，その後に任意の数の式を指定します。最初のパラメータ（ベクター）には、_binding form_（通常はシンボル）と、その後に `let` 式の残りの部分でその値がこの新しいローカルにバインドされる式を示す、任意の数のペアを含める必要があります。

[source, clojure]
----
(let [x (inc 1)
      y (+ x 1)]
  (println "Simple message from the body of a let")
  (* x y))
;; Simple message from the body of a let
;; => 6
----

前述の例では，記号 `x` は値 `(inc 1)` に束縛され，その値は 2 になり，記号 `y` は `x` と 1 の和に束縛され，その値は 3 になります．これらの束縛が与えられると，式 `(println "Simple message from a body of a let")` と `(* x y)` が評価されます．


==== Blocks

JavaScriptでは、中括弧 `{` と `}` が「一緒に属する」コードのブロックを区切ります。 _ClojureScript_ のブロックは `do` 式を使って作成され、通常はコンソールに何かを出力したり、ロガーにログを書いたりするような、副作用のために使われます。

副作用とは、戻り値には必要のないものを指します。

`do` 式は、パラメータとして任意の数の他の式を受け入れますが、最後の式からのみ戻り値を返します。

[source, clojure]
----
(do
  (println "hello world")
  (println "hola mundo")
  (* 3 5) ;; this value will not be returned; it is thrown away
  (+ 1 2))

;; hello world
;; hola mundo
;; => 3
----

前のセクションで説明した `let` 式の本体は、複数の表現を可能にするという点で `do` 式と非常によく似ています。実際、`let` には暗黙の `do` があります。

==== Loops

_ClojureScript_ の機能的なアプローチは、JavaScriptの `for` のような、標準的でよく知られた、ステートメントベースのループを持たないことを意味します。_ClojureScript_ のループは再帰を使って処理されます。 再帰は時に、問題をどのようにモデル化するかについて、命令型言語とは少し異なる方法で追加的に考える必要があります。 

他の言語で `for` が使われている一般的なパターンの多くは、他の関数をパラメータとして受け入れる高階の関数を使って実現されています。


===== Looping with loop/recur

ここでは、`loop` と` recur` という形式で再帰を使ってループを表現する方法を見てみましょう。 `loop` ではバインディングの空のリストを定義し（`let` との対称性に注目してください）、`recur` ではそれらのバインディングに新しい値を設定して、実行をループポイントに戻します。 

例を見てみましょう。

[source, clojure]
----
(loop [x 0]
  (println "Looping with " x)
  (if (= x 2)
    (println "Done looping!")
    (recur (inc x))))
;; Looping with 0
;; Looping with 1
;; Looping with 2
;; Done looping!
;; => nil
----

上のスニペットでは，名前 `x` を値 `0` にバインドして，ボディを実行しています．最初に条件が満たされなかったので、`recur` で再実行し、`inc` 関数でバインド値をインクリメントします。これを条件が満たされるまでもう一度行い、それ以上の `recur` の呼び出しがないので、ループを終了します。

なお、`recur` を呼び出すことができるのは、`loop` だけではありません。
関数の中で `recur` を使うと，関数の本体が新しいバインディングで再帰的に実行されます．

[source, clojure]
----
(defn recursive-function
  [x]
  (println "Looping with" x)
  (if (= x 2)
    (println "Done looping!")
    (recur (inc x))))

(recursive-function 0)
;; Looping with 0
;; Looping with 1
;; Looping with 2
;; Done looping!
;; => nil
----


===== Replacing for loops with higher-order functions

命令型のプログラミング言語では、データを反復処理して変換するために `for` ループを使用するのが一般的で、通常は以下のような意図で使用されます。

- 反復可能なデータのすべての値を変換し、別の反復可能なデータを生成する。
- イテレート可能な要素を特定の条件でフィルタリングする。
- 反復可能なデータを、各反復が前の反復の結果に依存するような値に変換する。
- 反復可能な値のすべてについて計算を実行する

上記のアクションは，ClojureScriptの高階関数や構文構造で書き換えられています．

反復可能なデータ構造の中のすべての値を変換するために，`map`関数を使います．

[source, clojure]
----
(map inc [0 1 2])
;; => (1 2 3)
----

`map` の最初のパラメータには、1つの引数を取り、値を返す_任意の関数を指定できます。 例えば、グラフ作成のアプリケーションで、一連の _x_ の値に対して、方程式 `y&#160;=&#160;3x&#160;+&#160;5` をグラフ化したい場合、次のようにして _y_ の値を得ることができます。

[source, clojure]
----
(defn y-value [x] (+ (* 3 x) 5))

(map y-value [1 2 3 4 5])
;; => (8 11 14 17 20)
----

関数が短い場合は、代わりに無名関数を使うことができます。通常の構文でも短縮構文でもOKです。

[source, clojure]
----
(map (fn [x] (+ (* 3 x) 5)) [1 2 3 4 5])
;; => (8 11 14 17 20)

(map #(+ (* 3 %) 5) [1 2 3 4 5])
;; => (8 11 14 17 20)
----

データ構造の値をフィルタリングするには，`filter` 関数を使います．この関数は，述語とシーケンスを受け取り，与えられた述語に対して `true` を返した要素だけを含む新しいシーケンスを与えます．

[source, clojure]
----
(filter odd? [1 2 3 4])
;; => (1 3)
----

ここでも，`true` または `false` を返す任意の関数を `filter` の第一引数として使用することができます。 ここでは、5文字以下の単語のみを保持する例を示します。( `count` 関数は、引数の長さを返します)。

[source, clojure]
----
(filter (fn [word] (< (count word) 5)) ["ant" "baboon" "crab" "duck" "echidna" "fox"])
;; => ("ant" "crab" "duck" "fox")
----

反復可能な値を単一の値に変換し、反復の各ステップで中間結果を蓄積するには、`reduce` を使用します。 `reduce` は、値を蓄積する関数、オプションの初期値、およびコレクションを取ります。

[source, clojure]
----
(reduce + 0 [1 2 3 4])
;; => 10
----

繰り返しになりますが、 `reduce` の第一引数に独自の関数を指定することができますが、その関数には _2つの_ パラメータが必要です。1つ目のパラメータは「累積値」で、2つ目のパラメータは処理されるコレクションアイテムです。この関数は、リストの次の項目の累算器となる値を返します。 例えば、数字の集合の二乗和を求める方法は以下の通りです（これは統計学では重要な計算です）。別の関数を使う

[source, clojure]
----
(defn sum-squares
  [accumulator item]
  (+ accumulator (* item item)))

(reduce sum-squares 0 [3 4 5])
;; => 50
----

...そして、無名の関数では、

[source, clojure]
----
(reduce (fn [acc item] (+ acc (* item item))) 0 [3 4 5])
;; => 50
----

ここでは、単語の集合に含まれる文字数の合計を求める `reduce` を紹介します。

[source, clojure]
----
(reduce (fn [acc word] (+ acc (count word))) 0 ["ant" "bee" "crab" "duck"])
;; => 14
----

ここでは、短い構文を使用していません。短い構文は、タイプ数は少なくて済みますが、可読性が低くなる可能性があるからです。そして、新しい言語を始めるときには、書いたものを読めることが重要です。新しい言語を始めるときには、自分が書いたものを読めることが重要です！もし、短い構文に慣れているのであれば、自由に使ってください。

アキュムレータの開始値を慎重に選ぶことを忘れないでください。もし、`reduce`を使って一連の数字の積を求めようとしたら、ゼロではなく1から始めなければなりません。

[source, clojure]
----
;; wrong starting value
(reduce * 0 [3 4 5])
;; => 0

;; correct starting accumulator
(reduce * 1 [3 4 5])
;; => 60
----


===== `for` sequence comprehensions

ClojureScriptでは、`for` 構文は反復処理ではなく、シーケンスを生成するために使用されます。これは「シーケンス内包(sequence comprehension)」とも呼ばれる操作です。このセクションでは、その仕組みを学び、宣言的にシーケンスを構築するために使用します。

`for` はバインディングのベクトルと式を受け取り、その式を評価した結果のシーケンスを生成します。例を見てみましょう。

[source, clojure]
----
(for [x [1 2 3]]
  [x (* x x)])
;; => ([1 1] [2 4] [3 9])
----

この例では，`x` は，ベクトル `[1 2 3]` の各項目に順に束縛され，元の項目を二乗した2項目のベクトルの新しいシーケンスを返します．

`for` は複数のバインディングをサポートしており、これによって、命令型言語の `for` ループの入れ子のように、コレクションが入れ子になって反復されます。最も内側のバインディングは "最速 "で反復します。

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]]
  [x y])

;; => ([1 4] [1 5] [2 4] [2 5] [3 4] [3 5])
----

ローカルバインディングを作成するには `:let` 、シーケンス生成から抜け出すには `:while` 、値をフィルタリングするには `:when` という3つの修飾子を使って、バインディングをフォローすることもできます。

以下は `:let` 修飾子を使ったローカルバインディングの例です。この修飾子で定義されたバインディングは式の中で利用できることに注意してください。

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]]
  z)
;; => (5 6 6 7 7 8)
----

`:while` 修飾子を使って、条件が満たされなくなったときにシーケンスの生成を停止させる条件を表現することができます。以下にその例を示します。

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :while (= y 4)]
  [x y])

;; => ([1 4] [2 4] [3 4])
----

生成された値をフィルタリングするには、次の例のように `:when` 修飾子を使用します。

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :when (= (+ x y) 6)]
  [x y])

;; => ([1 5] [2 4])
----

上記のような修飾語を組み合わせることで、複雑な配列の生成を表現したり、内包の意図をより明確に表現することができます。

[source, clojure]
----
(for [x [1 2 3]
      y [4 5]
      :let [z (+ x y)]
      :when (= z 6)]
  [x y])

;; => ([1 5] [2 4])
----

命令型プログラミング言語における `for` 構造の最も一般的な使用方法を説明した際に、結果を気にせずにシーケンスの各値に対して計算を実行したい場合があると述べました。おそらく、シーケンスの値である種の副次効果を得るためにこれを行うのでしょう。

ClojureScriptは `doseq` 構文を提供しています。これは `for` に類似していますが、式を実行し、結果の値を破棄して `nil` を返します。

[source, clojure]
----
(doseq [x [1 2 3]
        y [4 5]
       :let [z (+ x y)]]
  (println x "+" y "=" z))

;; 1 + 4 = 5
;; 1 + 5 = 6
;; 2 + 4 = 6
;; 2 + 5 = 7
;; 3 + 4 = 7
;; 3 + 5 = 8
;; => nil
----

もし、コレクションの各アイテムに対して、反復処理や（ `println` のような）副次的な操作を行いたいのであれば、内部的に高速リダクションを使用する特殊な関数 `run!` を使用することができます。

[source, clojure]
----
(run! println [1 2 3])
;; 1
;; 2
;; 3
;; => nil
----

この関数は、明示的に `nil` を返します。


=== Collection types

==== Immutable and persistent

以前、ClojureScriptのコレクションは永続的かつ不変的であると述べましたが、その意味を説明しませんでした。

不変データ構造とは、その名が示すように、変更できないデータ構造のことです。不変データ構造ではインプレース更新ができません。

例を挙げて説明しましょう。`conj` (join)演算を使ってベクトルに値を追加します。

[source, clojure]
----
(let [xs [1 2 3]
      ys (conj xs 4)]
  (println "xs:" xs)
  (println "ys:" ys))

;; xs: [1 2 3]
;; ys: [1 2 3 4]
;; => nil
----

ご覧のように，`xs` ベクトルに要素を追加した新しいバージョンを派生させ，要素を追加した新しいベクトル `ys` を得ました．しかし，`xs` ベクトルは不変であるため，変更されませんでした．

永続的なデータ構造とは、変換したときに元のバージョンを残して新しいバージョンを返すデータ構造のことです。ClojureScriptでは、_structural sharing_ と呼ばれる実装技術を用いて、メモリと時間の効率化を図っています。ここでは、2つのバージョンの値の間で共有されるデータのほとんどは複製されず、必要最小限のデータをコピーすることで、値の変換が実装されます。

構造的共有がどのように機能するかの例をご覧になりたい方は、この先をお読みください。詳細に興味がない場合は、xref:the-sequence-abstraction[次のセクション]に読み飛ばしてください。

ClojureScriptのデータ構造の構造的共有を説明するために、データ構造の新旧バージョンのいくつかの部分が実際に同じオブジェクトであるかどうかを `identical?` という述語で比較してみましょう。この目的のために、リストデータ型を使用します。

[source, clojure]
----
(let [xs (list 1 2 3)
      ys (cons 0 xs)]
  (println "xs:" xs)
  (println "ys:" ys)
  (println "(rest ys):" (rest ys))
  (identical? xs (rest ys)))

;; xs: (1 2 3)
;; ys: (0 1 2 3)
;; (rest ys): (1 2 3)
;; => true
----

この例では，`xs` リストに値を追加するために `cons` （construct）を使用しており，要素が追加された新しいリスト `ys` が得られていることがわかります．リスト `ys` の `rest` （最初の値を除くすべての値）は，メモリ上で `xs` リストと同じオブジェクトであり，`xs` と `ys` は構造を共有しています．


[[the-sequence-abstraction]]
==== The sequence abstraction

ClojureScriptの中心的な抽象概念の1つは _sequence_ で、これはリストと考えることができ、任意のコレクション型から派生することができます。シーケンスは他のコレクション型と同様に永続的で不変であり、ClojureScriptの中核となる関数の多くはシーケンスを返します。

シーケンスを生成するために使用できる型は「seqables」と呼ばれ、 `seq` を呼び出してシーケンスを返すことができます。シーケンスは2つの基本的な操作をサポートしています: `first` と `rest` です。これらはどちらも，与えられた引数に対して `seq` を呼び出します．

[source, clojure]
----
(first [1 2 3])
;; => 1

(rest [1 2 3])
;; => (2 3)
----

`seq` をseqableで呼び出すと、seqableが空の場合とそうでない場合で異なる結果になります。空の場合は `nil` を返し、そうでない場合はシーケンスを返します。

[source, clojure]
----
(seq [])
;; => nil

(seq [1 2 3])
;; => (1 2 3)
----

`next` は `rest` と同様のシーケンス操作ですが、要素数が 1 または 0 のシーケンスで呼び出された場合に `nil` 値を返す点で後者とは異なります。前述のシーケンスが与えられた場合、`rest` が返す空のシーケンスは真のブール値として評価されるのに対し、`next` が返す `nil` 値は偽のブール値として評価されることに注意してください (xref:truthiness-section[この章の後半にある _truthiness_ のセクションを参照してください])。

[source, clojure]
----
(rest [])
;; => ()

(next [])
;; => nil

(rest [1 2 3])
;; => (2 3)

(next [1 2 3])
;; => (2 3)
----


===== nil-punning

`seq` はコレクションが空の場合に `nil` を返し、 `nil` はboolean文脈ではfalseと評価されるので、 `seq` 関数を使ってコレクションが空であるかどうかを確認することができます。これを技術的には nil-punning と呼びます。

[source, clojure]
----
(defn print-coll
  [coll]
  (when (seq coll)
    (println "Saw " (first coll))
    (recur (rest coll))))

(print-coll [1 2 3])
;; Saw 1
;; Saw 2
;; Saw 3
;; => nil

(print-coll #{1 2 3})
;; Saw 1
;; Saw 3
;; Saw 2
;; => nil
----

`nil` はseqableでもsequenceでもありませんが、これまで見てきたすべての関数でサポートされています。

[source, clojure]
----
(seq nil)
;; => nil

(first nil)
;; => nil

(rest nil)
;; => ()
----


===== Functions that work on sequences

コレクションを変換するClojureScriptのコア関数は、引数からシーケンスを作成し、前のセクションで学んだ汎用シーケンス操作の観点から実装されています。これにより、seqableな任意のデータ型に使用できるので、汎用性が高くなります。それでは、さまざまなseqableを使って、 `map` をどのように使うかを見てみましょう。

[source, clojure]
----
(map inc [1 2 3])
;; => (2 3 4)

(map inc #{1 2 3})
;; => (2 4 3)

(map count {:a 41 :b 40})
;; => (2 2)

(map inc '(1 2 3))
;; => (2 3 4)
----

注意: マップコレクションに対して `map` 関数を使用すると，高階の関数は，キーと値を含む2項目のベクトルをマップから受け取ります．次の例では，xref:destructuring-section[destructuring]を使って，キーと値を取得しています．

[source,clojure]
----
(map (fn [[key value]] (* value value))
     {:ten 10 :seven 7 :four 4})
;; => (100 49 16)
----

もちろん、同じ操作は、値のシーケンスを取得するだけの、より慣用的な方法で行うことができます。

[source,clojure]
----
(map (fn [value] (* value value))
     (vals {:ten 10 :seven 7 :four 4}))
;; => (100 49 16)
----

お気づきかもしれませんが、シーケンスを操作する関数は、空のコレクションや、 `nil` の値があっても安全に使用することができます。

[source, clojure]
----
(map inc [])
;; => ()

(map inc #{})
;; => ()

(map inc nil)
;; => ()
----

`map` 、 `filter` 、 `reduce` などの典型的な例をすでに見ましたが、ClojureScriptはコア名前空間で汎用的なシーケンス操作を多数提供しています。これから学ぶ操作の多くは、seqableで動作するか、ユーザー定義の型に拡張可能であることに注意してください。

述語  `coll?` を使って、値がコレクション型であるかどうかを問い合わせることができます。

[source, clojure]
----
(coll? nil)
;; => false

(coll? [1 2 3])
;; => true

(coll? {:language "ClojureScript" :file-extension "cljs"})
;; => true

(coll? "ClojureScript")
;; => false
----

値がシーケンスであるかどうか（ `seq?` で）、seqableであるかどうか（ `seqable?` で）をチェックするための同様の述語が存在します。

[source, clojure]
----
(seq? nil)
;; => false
(seqable? nil)
;; => false

(seq? [])
;; => false
(seqable? [])
;; => true

(seq? #{1 2 3})
;; => false
(seqable? #{1 2 3})
;; => true

(seq? "ClojureScript")
;; => false
(seqable? "ClojureScript")
;; => false
----

一定時間内に数えることができるコレクションに対しては、 `count` という操作を使うことができます。文字列はコレクションでもシーケンスでもseqableでもありませんが、この操作は文字列でも動作します。

[source, clojure]
----
(count nil)
;; => 0

(count [1 2 3])
;; => 3

(count {:language "ClojureScript" :file-extension "cljs"})
;; => 2

(count "ClojureScript")
;; => 13
----

また、 `empty` 関数を使えば、与えられたコレクションの空のバリアントを得ることができます。

[source, clojure]
----
(empty nil)
;; => nil

(empty [1 2 3])
;; => []

(empty #{1 2 3})
;; => #{}
----

与えられたコレクションが空であれば、 `empty?` 述語はtrueを返します。

[source, clojure]
----
(empty? nil)
;; => true

(empty? [])
;; => true

(empty? #{1 2 3})
;; => false
----

`conj` 操作はコレクションに要素を追加しますが、コレクションの種類によって異なる「場所」に追加されることがあります。コレクションの種類に応じて、最もパフォーマンスの高い場所に追加されますが、すべてのコレクションが定義された順序を持つわけではないことに注意してください。

`conj` に追加したい要素をいくつでも渡すことができるので、実際に見てみましょう。

[source, clojure]
----
(conj nil 42)
;; => (42)

(conj [1 2] 3)
;; => [1 2 3]

(conj [1 2] 3 4 5)
;; => [1 2 3 4 5]

(conj '(1 2) 0)
;; => (0 1 2)

(conj #{1 2 3} 4)
;; => #{1 3 2 4}

(conj {:language "ClojureScript"} [:file-extension "cljs"])
;; => {:language "ClojureScript", :file-extension "cljs"}
----


===== Laziness

ClojureScriptのシーケンスを返す関数のほとんどは、新しいシーケンスを熱心に(eagerly)作成する代わりに、遅延シーケンスを生成します。遅延シーケンスは、要求に応じてコンテンツを生成しますが、通常は反復処理の際に生成します。遅延は、必要以上の作業をしないことを保証し、無限に続く可能性のあるシーケンスを通常のシーケンスとして扱えるようにします。

整数の範囲を生成する `range`  関数を考えてみましょう。

[source, clojure]
----
(range 5)
;; => (0 1 2 3 4)
(range 1 10)
;; => (1 2 3 4 5 6 7 8 9)
(range 10 100 15)
;; (10 25 40 55 70 85)
----

単に  `(range)`  と言えば、すべての整数の無限列が得られます。REPLは式を完全に評価したいので、非常に長い時間待つ覚悟がない限り、REPLでこれを試してはいけません*。

これは、REPLが式を完全に評価したいと考えているからです。ここでは、人工的な例を示します。例えば、グラフ作成プログラムを書いていて、 _y_ = 2  _x_  ^2^ + 5 という方程式をグラフ化していて、  _y_  の値が 100 未満になる _x_  の値だけを求めたいとします。0から100までのすべての数字を生成することができますが、これで十分でしょう。

[source,clojure]
----
(take-while (fn [x] (< (+ (* 2 x x) 5) 100))
            (range 0 100))
;; => (0 1 2 3 4 5 6)
----

==== Collections in depth

ClojureScriptのシーケンスの抽象化と、シーケンスを操作する汎用関数のいくつかについては理解できたので、今度は具体的なコレクションタイプとそれらがサポートする操作について説明します。


===== Lists

ClojureScriptでは、リストは主にシンボルをまとめてプログラムにするためのデータ構造として使われています。他のLisp族とは異なり、ClojureScriptの構文構造の多くは、リストとは異なるデータ構造（ベクターやマップ）を使用しています。 これによりコードの統一性は失われますが、読みやすさの向上は十分に価値があります。

ClojureScriptのリストは、各ノードが値とリストの残りの部分へのポインタを含む、単結合リストと考えることができます。これにより、アイテムをリストの先頭に追加することが自然に（そして速く！）できるようになります。先頭への追加操作は，`cons` 関数を用いて行います．

[source, clojure]
----
(cons 0 (cons 1 (cons 2 ())))
;; => (0 1 2)
----

空のリストを表すためにリテラル `()` を使いました。このリテラルにはシンボルが含まれていないので、関数呼び出しとしては扱われません。しかし、要素を含むリスト・リテラルを使用する場合は、ClojureScriptが関数呼び出しとして評価するのを防ぐために、引用符を付ける必要があります。

[source, clojure]
----
(cons 0 '(1 2))
;; => (0 1 2)
----

リストコレクションでは、先頭が一定時間で追加できる位置なので、リストの `conj` 操作は自然にアイテムを先頭に追加します。

[source, clojure]
----
(conj '(1 2) 0)
;; => (0 1 2)
----

リストやその他のClojureScriptのデータ構造は、 `peek` 、 `pop` 、 `conj` 関数を使ってスタックとして使用することができます。スタックの先頭は `conj` が要素を追加する "場所" になり、`conj` はスタックのプッシュ操作と同等になることに注意してください。リストの場合、 `conj` はリストの先頭に要素を追加し、 `peek` はリストの最初の要素を返し、 `pop` は最初の要素を除くすべての要素を含むリストを返します。

なお、スタックを返す2つの操作（ `conj` と `pop` ）は、スタックに使用するコレクションの型を変更しません。

[source, clojure]
----
(def list-stack '(0 1 2))

(peek list-stack)
;; => 0

(pop list-stack)
;; => (1 2)

(type (pop list-stack))
;; => cljs.core/List

(conj list-stack -1)
;; => (-1 0 1 2)

(type (conj list-stack -1))
;; => cljs.core/List
----

リストが苦手とするものに、インデックス付きのランダムアクセスがあります。リストはメモリ上の単一のリンクリストのような構造に格納されているため、任意のインデックスへのランダムなアクセスは、要求されたアイテムを取得するか、インデックスの境界外エラーを投げるために線形走査を必要とします。遅延シーケンスのようなインデックスを持たない順序付きコレクションも、この制限を受けます。


===== Vectors

ベクターは、ClojureScriptで最も一般的なデータ構造の一つです。ベクターは、関数の引数宣言や `let` バインディングなど、伝統的な Lisps がリストを使用する多くの場所で構文として使用されます。

ClojureScriptのベクターは、その構文リテラルに大括弧 `[]` を持っています。ベクターは `vector` で作成でき、`vec` では別のコレクションから作成できます。

[source,clojure]
----
(vector? [0 1 2])
;; => true

(vector 0 1 2)
;; => [0 1 2]

(vec '(0 1 2))
;; => [0 1 2]
----

ベクトルは，リストのように，異質な値の順序付けられた集合体です．リストとは異なり，ベクターは末尾から自然に成長するので，`conj`操作はベクターの末尾にアイテムを追加します．ベクトルの末尾への挿入は，実質的に一定時間で行われます。

[source,clojure]
----
(conj [0 1] 2)
;; => [0 1 2]
----

リストとベクターを区別するもう一つの点は，ベクターはインデックス付きのコレクションであり，効率的なランダムインデックスアクセスと非破壊更新をサポートしているということです．インデックスを指定して値を取得するには， `nth` 関数を使用します．

[source, clojure]
----
(nth [0 1 2] 0)
;; => 0
----

ベクトルは，連続した数値のキー（インデックス）と値を関連付けているので，連想データ構造として扱うことができます．ClojureScriptには、連想データ構造とキーと値のペアのセットを与えると、キーに対応する値を変更した新しいデータ構造を生成する、 `assoc` 関数があります。インデックスは、ベクトルの最初の要素に対してゼロから始まります。

[source, clojure]
----
(assoc ["cero" "uno" "two"] 2 "dos")
;; => ["cero" "uno" "dos"]
----

なお、キーに `assoc` できるのは、すでにベクターに含まれているか、ベクターの最後の位置である場合だけです。

[source, clojure]
----
(assoc ["cero" "uno" "dos"] 3 "tres")
;; => ["cero" "uno" "dos" "tres"]

(assoc ["cero" "uno" "dos"] 4 "cuatro")
;; Error: Index 4 out of bounds [0,3]
----

意外かもしれませんが、連想データ構造は関数としても利用できます。連想データ構造は，キーとそれに関連付けられた値の関数です．ベクトルの場合，与えられたキーが存在しない場合は例外が発生します．

[source, clojure]
----
(["cero" "uno" "dos"] 0)
;; => "cero"

(["cero" "uno" "dos"] 2)
;; => "dos"

(["cero" "uno" "dos"] 3)
;; Error: Not item 3 in vector of length 3
----

リストと同様に，ベクトルも `peek`, `pop`, `conj` 関数を用いてスタックとして使用することができます．ただし，ベクタはリストとは逆にコレクションの最後の端から成長することに注意してください．

[source, clojure]
----
(def vector-stack [0 1 2])

(peek vector-stack)
;; => 2

(pop vector-stack)
;; => [0 1]

(type (pop vector-stack))
;; => cljs.core/PersistentVector

(conj vector-stack 3)
;; => [0 1 2 3]

(type (conj vector-stack 3))
;; => cljs.core/PersistentVector
----

`map` と `filter` は遅延シーケンスを返しますが、これらの操作を実行した後に完全に実現されたシーケンスが必要になることはよくあることなので、このような関数のベクトルを返すカウンターパートが `mapv` と `filterv` として用意されています。これらの関数は，遅延シーケンスからベクトルを生成するよりも高速であり，意図をより明確にすることができるという利点があります。

[source, clojure]
----
(map inc [0 1 2])
;; => (1 2 3)

(type (map inc [0 1 2]))
;; => cljs.core/LazySeq

(mapv inc [0 1 2])
;; => [1 2 3]

(type (mapv inc [0 1 2]))
;; => cljs.core/PersistentVector
----

===== Maps

マップはClojureScriptではどこにでもあります。ベクターのように、特に xref:metadata-section[metadata] を変数に付加するための構文としても使用されています。ClojureScriptの任意のデータ構造は、マップのキーとして使用できますが、関数として呼び出すこともできるため、キーワードを使用するのが一般的です。

ClojureScriptのマップは、文字通り中括弧`{}`で囲まれたキーと値のペアとして書かれます。また、`hash-map`関数を使ってマップを作成することもできます。

[source,clojure]
----
(map? {:name "Cirilla"})
;; => true

(hash-map :name "Cirilla")
;; => {:name "Cirilla"}

(hash-map :name "Cirilla" :surname "Fiona")
;; => {:name "Cirilla" :surname "Fiona"}
----

通常のマップは特定の順序を持たないので、 `conj` 操作は1つまたは複数のキーバリューペアをマップに追加するだけです。マップに対する `conj` は、最後の引数として、1つまたは複数のキーバリューペアのシーケンスを想定しています。

[source,clojure]
----
(def ciri {:name "Cirilla"})

(conj ciri [:surname "Fiona"])
;; => {:name "Cirilla", :surname "Fiona"}

(conj ciri [:surname "Fiona"] [:occupation "Wizard"])
;; => {:name "Cirilla", :surname "Fiona", :occupation "Wizard"}
----

先ほどの例では、たまたま順番が守られていましたが、キーの数が多い場合には、順番が守られていないことがわかります。

マップは，キーと値を関連付けるもので，連想データ構造です．マップは， `assoc` で連想を追加することができ，ベクタとは異なり， `dissoc` で連想を削除することができます．また， `assoc` は既存のキーの値を更新します．それでは，これらの関数を見ていきましょう．

[source,clojure]
----
(assoc {:name "Cirilla"} :surname "Fiona")
;; => {:name "Cirilla", :surname "Fiona"}
(assoc {:name "Cirilla"} :name "Alfonso")
;; => {:name "Alfonso"}
(dissoc {:name "Cirilla"} :name)
;; => {}
----

マップは，そのキーの関数でもあり，与えられたキーに関連する値を返します．ベクターとは異なり，マップに存在しないキーを指定すると，`nil`を返します．

[source,clojure]
----
({:name "Cirilla"} :name)
;; => "Cirilla"

({:name "Cirilla"} :surname)
;; => nil
----

ClojureScriptでは、ソートされていないバージョンと同じように動作しますが、繰り返し処理するときに順序を保持するソートされたハッシュマップも提供しています。デフォルトの順序でソートされたマップを作成するには、 `sorted-map` を使用します。

[source,clojure]
----
(def sm (sorted-map :c 2 :b 1 :a 0))
;; => {:a 0, :b 1, :c 2}

(keys sm)
;; => (:a :b :c)
----

カスタムの順序付けが必要な場合には，`sorted-map-by`にコンパレータ関数を与えることができます。ここでは，組み込みの`compare`関数が返す値を反転させる例を見てみましょう。コンパレータ関数は，比較する2つの項目を受け取り，-1（最初の項目が2番目の項目よりも小さい場合），0（両者が等しい場合），1（最初の項目が2番目の項目よりも大きい場合）を返します。

[source,clojure]
----
(defn reverse-compare [a b] (compare b a))

(def sm (sorted-map-by reverse-compare :a 0 :b 1 :c 2))
;; => {:c 2, :b 1, :a 0}

(keys sm)
;; => (:c :b :a)
----


===== Sets

ClojureScriptのセットは、 `#{}` で囲まれた値というリテラルな構文を持ち、 `set` コンストラクタで作成することができます。セットは、重複のない値の順不同のコレクションです。

[source,clojure]
----
(set? #{\a \e \i \o \u})
;; => true

(set [1 1 2 3])
;; => #{1 2 3}
----

セットリテラルに重複した値を含めることはできません。誤って重複した値を含むセットリテラルを書いてしまうと、エラーが発生します。

[source,clojure]
----
#{1 1 2 3}
;; clojure.lang.ExceptionInfo: Duplicate key: 1
----

セットを使って実行できる操作はたくさんありますが、それらは `clojure.set` という名前空間にあるので、インポートする必要があります。 xref:namespace-section[名前空間の詳細] については後ほど説明しますが、今は `clojure.set` という名前空間を読み込み、それを `s` シンボルにバインドしているということだけ知っていれば十分です。

[source,clojure]
----
(require '[clojure.set :as s])

(def danish-vowels #{\a \e \i \o \u \æ \ø \å})
;; => #{"a" "e" "å" "æ" "i" "o" "u" "ø"}

(def spanish-vowels #{\a \e \i \o \u})
;; => #{"a" "e" "i" "o" "u"}

(s/difference danish-vowels spanish-vowels)
;; => #{"å" "æ" "ø"}

(s/union danish-vowels spanish-vowels)
;; => #{"a" "e" "å" "æ" "i" "o" "u" "ø"}

(s/intersection danish-vowels spanish-vowels)
;; => #{"a" "e" "i" "o" "u"}
----

不変のセットの良い特性は、ネストできることです。変更可能なセットを持つ言語では、重複した値を含んでしまうことがありますが、ClojureScriptではそのようなことはありません。実際、すべてのClojureScriptのデータ構造は、不変性のために任意の入れ子にすることができます。

セットは、他のコレクションと同様に、汎用の `conj` 操作もサポートしています。

[source,clojure]
----
(def spanish-vowels #{\a \e \i \o \u})
;; => #{"a" "e" "i" "o" "u"}

(def danish-vowels (conj spanish-vowels \æ \ø \å))
;; => #{"a" "e" "i" "o" "u" "æ" "ø" "å"}

(conj #{1 2 3} 1)
;; => #{1 3 2}
----

セットは、含まれる値を自分自身に関連付ける読み取り専用の連想データとして機能します。ClojureScriptでは、 `nil` と `false` を除くすべての値が真実であるため、セットを述語関数として使用することができます。

[source,clojure]
----
(def vowels #{\a \e \i \o \u})
;; => #{"a" "e" "i" "o" "u"}

(get vowels \b)
;; => nil

(contains? vowels \b)
;; => false

(vowels \a)
;; => "a"

(vowels \z)
;; => nil

(filter vowels "Hound dog")
;; => ("o" "u" "o")
----

セットには、マップのようにソートされたものがあり、マップの `sorted-map` や `sorted-map-by` と同じように、`sorted-set` や `sorted-set-by` という関数を使って作成します。

[source,clojure]
----
(def unordered-set #{[0] [1] [2]})
;; => #{[0] [2] [1]}

(seq unordered-set)
;; => ([0] [2] [1])

(def ordered-set (sorted-set [0] [1] [2]))
;; =># {[0] [1] [2]}

(seq ordered-set)
;; => ([0] [1] [2])
----



===== Queues

ClojureScriptでは、永続的で不変的なキューも提供しています。キューは、他のコレクション型ほど広く使われていません。 キューは、 `#queue []` リテラル構文を使って作成できますが、便利なコンストラクタ関数はありません。

[source,clojure]
----
(def pq #queue [1 2 3])
;; => #queue [1 2 3]
----

キューに値を追加するために `conj` を使用すると、アイテムが背面に追加されます。

[source,clojure]
----
(def pq #queue [1 2 3])
;; => #queue [1 2 3]

(conj pq 4 5)
;; => #queue [1 2 3 4 5]
----

キューに関して留意すべきことは、スタック操作が通常のスタックセマンティクス（同じ端からのプッシュとポッピング）に従わないことです。 `pop` は前の位置から値を取り、 `conj` は要素を後ろに押します（追加します）。

[source,clojure]
----
(def pq #queue [1 2 3])
;; => #queue [1 2 3]

(peek pq)
;; => 1

(pop pq)
;; => #queue [2 3]

(conj pq 4)
;; => #queue [1 2 3 4]
----

キューは、リストやベクターほど頻繁に使われるものではありませんが、ClojureScriptで利用できることを知っておくと、時には便利なこともあるでしょう。


[[destructuring-section]]
=== Destructuring

デストラクションとは、その名が示すように、コレクションなどの構造化されたデータを分解し、その中の個々の部分に注目する方法です。ClojureScriptには、インデックス付きのシーケンスと連想データ構造の両方をデストラクションするための簡潔な構文が用意されており、バインディングが宣言されている任意の場所で使用することができます。

前述の説明をよりよく理解するために、デストラクションがどのように役立つのか例を見てみましょう。シーケンスがあって、1番目と3番目のアイテムにしか興味がないとします。 `nth` 関数を使えば，簡単に参照を得ることができます．

[source, clojure]
----
(let [v [0 1 2]
      fst (nth v 0)
      thrd (nth v 2)]
  [thrd fst])
;; => [2 0]
----

しかし、先ほどのコードは冗長すぎます。デストラクションでは、バインディングの左手側にあるベクターを使って、インデックス付きシーケンスの値をより簡潔に抽出することができます。

[source, clojure]
----
(let [[fst _ thrd] [0 1 2]]
  [thrd fst])
;; => [2 0]
----

上の例では，`[fst _ thrd]` がデストラクションの形式です．これはベクトルとして表現され、インデックス付きの値をそれぞれインデックス `0` と `2` に対応するシンボル `fst` と `thrd` にバインドするために使用されます。シンボル `_` は、興味のないインデックス（この場合は `1`）のプレースホルダとして使用されます。

デストラクションは、`let`という結合形式に限らず、`for`や`doseq`という特殊な形式や、関数の引数など、シンボルに値を結合するほとんどすべての場所で機能することに注意してください。ペアを受け取り、その位置を入れ替える関数を、関数の引数にデストラクション構文を使って非常に簡潔に書くことができます。

[source, clojure]
----
(defn swap-pair [[fst snd]]
  [snd fst])

(swap-pair [1 2])
;; => [2 1]

(swap-pair '(3 4))
;; => [4 3]
----

ベクトルを使った位置デストラクションは、シーケンスからインデックス付きの値を取り出すのに非常に便利ですが、デストラクションの際にシーケンスの残りの要素を破棄したくない場合もあります。 アンパサンドは、`&`が可変関数の引数を受け取るときに使用されるのと同様に、ベクトルのデストラクションフォームの中で、シーケンスの残りの部分をまとめるために使用することができます。

[source, clojure]
----
(let [[fst snd & more] (range 10)]
  {:first fst
   :snd snd
   :rest more})
;; => {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9)}
----

`0` のインデックスの値が `fst` に、`1` のインデックスの値が `snd` に、`2` 以降の要素のシーケンスが `more` シンボルにバインドされていることに注目してください。

データ構造をデストラクションしているときでも、データ構造全体に興味がある場合があります。これは、 `:as` キーワードで実現できます。デストラクションの形式の中で使用された場合、元のデータ構造はそのキーワードに続くシンボルに束縛されます。

[source, clojure]
----
(let [[fst snd & more :as original] (range 10)]
  {:first fst
   :snd snd
   :rest more
   :original original})
;; => {:first 0, :snd 1, :rest (2 3 4 5 6 7 8 9), :original (0 1 2 3 4 5 6 7 8 9)}
----

インデックス付きの配列がデストラクションされるだけでなく、連想データもデストラクションされます。そのデストラクションの結合形式は、ベクターではなくマップで表現され、キーは値を結合したいシンボル、値は連想データ構造の中で調べたいキーとなります。例を見てみましょう。

[source, clojure]
----
(let [{language :language} {:language "ClojureScript"}]
  language)
;; => "ClojureScript"
----

上の例では， `:language` キーに関連付けられた値を抽出して，それを `language` シンボルにバインドしています．存在しないキーを検索する場合は、シンボルは `nil` にバインドされます。

[source, clojure]
----
(let [{name :name} {:language "ClojureScript"}]
  name)
;; => nil
----

連想リストラクチャリングでは、分解しているデータ構造の中にキーが見つからない場合に使われるデフォルト値をバインディングに与えることができます。以下の例のように、デフォルト値には  `:or` キーワードに続くマップが使われます。

[source, clojure]
----
(let [{name :name :or {name "Anonymous"}} {:language "ClojureScript"}]
  name)
;; => "Anonymous"

(let [{name :name :or {name "Anonymous"}} {:name "Cirilla"}]
  name)
;; => "Cirilla"
----

連想法によるデストラクションでは、元のデータ構造を `:as` キーワードの後に置かれたシンボルにバインドすることもサポートしています。

[source, clojure]
----
(let [{name :name :as person} {:name "Cirilla" :age 49}]
  [name person])
;; => ["Cirilla" {:name "Cirilla" :age 49}]
----

連想データ構造のキーになるのは、キーワードだけではありません。数字、文字列、シンボルなど、さまざまなデータ構造がキーとして使用できるので、それらを使って構造を解除することもできます。ただし、シンボルが var ルックアップとして解決されるのを防ぐために、シンボルを引用符で囲む必要があります。

[source, clojure]
----
(let [{one 1} {0 "zero" 1 "one"}]
  one)
;; => "one"

(let [{name "name"} {"name" "Cirilla"}]
  name)
;; => "Cirilla"

(let [{lang 'language} {'language "ClojureScript"}]
  lang)
;; => "ClojureScript"
----

キーに対応する値は、通常、同等のシンボル表現に束縛され（たとえば、 `:language` の値をシンボル `language` に束縛する場合）、キーは通常、キーワード、文字列、またはシンボルであるため、ClojureScriptでは、これらのケースに対応する省略構文を提供しています。

ここでは、 `:keys` を使ってキーワードをデストラクションすることから始めて、これらすべての例を示します。

[source, clojure]
----
(let [{:keys [name surname]} {:name "Cirilla" :surname "Fiona"}]
  [name surname])
;; => ["Cirilla" "Fiona"]
----

例を見ればわかるように、 `:keys` キーワードを使って、シンボルのベクトルと結合形式で関連付けると、キーワード化されたシンボルに対応する値が結合されることになります。 `{:keys [name surname]}` というデストラクションは、 `{name :name surname :surname}` と同じですが、短くなっています。

文字列とシンボルの短縮構文は `:keys` とまったく同じように動作しますが、それぞれ `:strs` と `:syms` キーワードを使用します。

[source, clojure]
----
(let [{:strs [name surname]} {"name" "Cirilla" "surname" "Fiona"}]
  [name surname])
;; => ["Cirilla" "Fiona"]

(let [{:syms [name surname]} {'name "Cirilla" 'surname "Fiona"}]
  [name surname])
;; => ["Cirilla" "Fiona"]
----

構造を変えたいマップが名前付きのキーワードをキーとして持っている場合、`:keys` ベクトルの中でキーワードの構文を使って構造を変えることもできます。

[source, clojure]
----
(let [{:keys [::name ::surname]} {::name "Cirilla" ::surname "Fiona"}]
  [name surname])
;; => ["Cirilla" "Fiona"]
----

デストラクションの興味深い特性は、デストラクションフォームを任意にネストできることです。これにより、コレクション上のネストされたデータにアクセスするコードは、コレクションの構造を模倣しているため、非常に理解しやすくなります。

[source, clojure]
----
(let [{[fst snd] :languages} {:languages ["ClojureScript" "Clojure"]}]
  [snd fst])
;; => ["Clojure" "ClojureScript"]
----


=== Threading Macros

スレッディングマクロは，アロー関数とも呼ばれ，ネストした複数の関数呼び出しを行う際に，より読みやすいコードを書くことができます．

`(f (g (h x)))` があるとします。関数 `f` は、関数 `g` を複数回繰り返して実行した結果を第一引数として受け取ります。最も基本的な `->` スレッディングマクロを使って、これを読みやすい `(\-> x (h) (g) (f))` に変換することができます。

この結果は、矢印関数がマクロとして定義されているので、構文上の糖度であり、実行時のパフォーマンスを意味するものではありません。  `(\-> x (h) (g) (f))` は，コンパイル時に自動的に `(f (g (h x)))` に変換されます．

`h` , `g` , `f` の括弧はオプションであり、省略することができますのでご注意ください。 `(f (g (h x)))` は、 `(\-> x h g f)` と同じです。


==== `\->` (thread-first macro)

これは、第一引数を異なる式の第一引数に通すことから、*thread first* と呼ばれています。

より具体的な例として、スレッドマクロを使用しない場合のコードは次のようになります。

[source, clojure]
----
(def book {:name "Lady of the Lake"
           :readers 0})

(update (assoc book :age 1999) :readers inc)
;; => {:name "Lady of the lake" :age 1999 :readers 1}
----

このコードを書き換えて、`\->` スレッディングマクロを使うようにできる。

[source, clojure]
----
(-> book
    (assoc :age 1999)
    (update :readers inc))
;; => {:name "Lady of the lake" :age 1999 :readers 1}
----

なぜなら、 _ClojureScript_ (および _Clojure_ )のデータ構造変換用関数は、データ構造を受け取るための最初の引数を一貫して使用するからです。このスレッディングマクロは、データ構造を変換する際に特に役立ちます。


==== `\->>` (thread-last macro)

thread-lastマクロとthread-firstマクロの主な違いは、最初に与えられた引数を次の式の最初の引数として渡すのではなく、最後の引数として渡すことです。

例を見てみましょう。

[source, clojure]
----
(def numbers [1 2 3 4 5 6 7 8 9 0])

(take 2 (filter odd? (map inc numbers)))
;; => (3 5)
----

`\->>` スレッディングマクロを使って同じコードを書いた場合

[source, clojure]
----
(->> numbers
     (map inc)
     (filter odd?)
     (take 2))
;; => (3 5)
----

シーケンスやコレクションを扱う _ClojureScript_ 関数は、一貫して最後の引数位置を使用してデータを受け取るため、このスレッディングマクロはシーケンスやデータのコレクションを変換する際に特に有効です。


==== `as\->` (thread-as macro)

最後に、`\->` も `\->>` もどちらも適用できない場合があります。このような場合には、より柔軟な代替手段である `as\->` を使用する必要があります。これは、最初や最後だけでなく、任意の引数の位置にスレッドを通すことができます。

これは、2つの固定引数と、任意の数の式を想定しています。`\->` と同様に、最初の引数は値で、次のフォームに通すことができます。2番目の引数はバインディングの名前です。後続の各フォームでは、前の式の結果にバインド名を使うことができます。

例を見てみましょう。

[source, clojure]
----
(as-> numbers $
  (map inc $)
  (filter odd? $)
  (first $)
  (hash-map :result $ :id 1))
;; => {:result 3 :id 1}
----


==== `some\->`, `some\->>` (thread-some macros)

_ClojureScript_ が搭載している、より専門的なスレッディングマクロの2つです。これらは、類似のマクロである `\->` や `\->>` と同じように動作しますが、どちらかの式が `nil` と評価された場合に、式を短絡させる機能が追加されています。

別の例を見てみましょう。

[source, clojure]
----
(some-> (rand-nth [1 nil])
        (inc))
;; => 2

(some-> (rand-nth [1 nil])
        (inc))
;; => nil
----

これは、ヌルポインター例外を回避する簡単な方法です。


==== `cond\->`, `cond\->>` (thread-cond macros)

`cond\->` , `cond\->>` は、`\->` , `\->>` と同様に、パイプラインのいくつかのステップを条件付きでスキップする機能を提供するマクロです。その例を見てみましょう。

[source, clojure]
----
(defn describe-number
  [n]
  (cond-> []
    (odd? n) (conj "odd")
    (even? n) (conj "even")
    (zero? n) (conj "zero")
    (pos? n) (conj "positive")))

(describe-number 3)
;; => ["odd" "positive"]

(describe-number 4)
;; => ["even" "positive"]
----

値のスレッド化は、対応する条件が論理的に真と評価された場合にのみ行われます。


==== Additional Readings

- http://www.spacjer.com/blog/2015/11/09/lesser-known-clojure-variants-of-threading-macro/
- http://clojure.org/guides/threading_macros


[[reader-conditionals]]
=== Reader Conditionals

この言語機能により、Clojureの異なる方言が、ほとんどプラットフォームに依存しないが、いくつかのプラットフォーム依存のコードを必要とする共通のコードを共有することができます。

リーダーコンディショナルを使用するために必要なのは、拡張子が `.cljs` のソースファイルを `.cljc` にリネームすることだけです。リーダーコンディショナルは、拡張子が `.cljc` のファイルに配置されている場合にのみ動作するからです。


==== Standard (`#?`)

リーダーコンディショナルには、スタンダードとスプライシングの2種類があります。スタンダードのリーダーコンディショナルは、従来のcondと同様の動作をし、構文は次のようになります。

[source, clojure]
----
(defn parse-int
  [v]
  #?(:clj  (Integer/parseInt v)
     :cljs (js/parseInt v)))
----

ご覧のように、`#?` リーダーマクロはcondと非常によく似ていますが、違いは条件が単なるプラットフォームを識別するキーワードであるということです。`:cljs` は _ClojureScript_ 、 `:clj` は _Clojure_ を表しています。この方法の利点は、コンパイル時に評価されるので、これを使用することによるランタイムパフォーマンスのオーバーヘッドがないことです。

==== Splicing (`#?@`)

スプライシング・リーダーコンディショナルは、スタンダードと同じように動作し、リストを含む形式にスプライシングすることができます。そのためには、 `#?@` リーダーマクロが使われ、コードは次のようになります。

[source, clojure]
----
(defn make-list
  []
  (list #?@(:clj  [5 6 7 8]
            :cljs [1 2 3 4])))

;; On ClojureScript
(make-list)
;; => (1 2 3 4)
----

_ClojureScript_ コンパイラは、そのコードをこのように読みます。

[source, clojure]
----
(defn make-list
  []
  (list 1 2 3 4))
----

スプライシング・リーダーコンディショナルは、複数のトップレベルフォームをスプライシングするために使用することはできませんので、以下のコードは間違いです。

[source, clojure]
----
#?@(:cljs [(defn func-a [] :a)
           (defn func-b [] :b)])
;; => #error "Reader conditional splicing not allowed at the top level."
----

必要であれば、複数のフォームを使用することもできますし、 `do` ブロックで複数のフォームをまとめて使用することもできます。

[source, clojure]
----
#?(:cljs (defn func-a [] :a))
#?(:cljs (defn func-b [] :b))

;; Or

#?(:cljs
   (do
     (defn func-a [] :a)
     (defn func-b [] :b)))
----


==== More readings

- http://clojure.org/guides/reader_conditionals
- https://danielcompton.net/2015/06/10/clojure-reader-conditionals-by-example
- https://github.com/funcool/cuerdas (リーダーコンディショナルを使った小さなプロジェクトの例)

[[namespace-section]]
=== Namespaces

==== Defining a namespace

名前空間は、ClojureScriptのコードモジュール化の基本単位です。名前空間は、JavaのパッケージやRubyやPythonのモジュールに類似しており、 `ns` マクロで定義できます。ClojureScriptのソースを少しでも見たことがあれば、ファイルの先頭にこのようなものがあることに気づくかもしれません。

[source, clojure]
----
(ns myapp.core
  "Some docstring for the namespace.")

(def x "hello")
----

名前空間は動的なものであり、いつでも作成することができます。しかし、慣例として、1つのファイルに1つの名前空間を持つことになっています。当然のことながら、通常、名前空間の定義はファイルの先頭にあり、その後にオプションのdocstringが続きます。

前回までに、varsとsymbolについて説明しました。あなたが定義したすべての var は、その名前空間と関連付けられます。具体的な名前空間を定義しない場合は、デフォルトの "cljs.user "という名前空間が使用されます。

[source, clojure]
----
(def x "hello")
;; => #'cljs.user/x
----


==== Loading other namespaces

名前空間とその中の変数を定義するのはとても簡単ですが、他の名前空間のシンボルを使用できない場合はあまり便利ではありません。この目的のために、 `ns` マクロは他の名前空間をロードする簡単な方法を提供します。

次のことを守りましょう。

[source, clojure]
----
(ns myapp.main
  (:require myapp.core
            clojure.string))

(clojure.string/upper-case myapp.core/x)
;; => "HELLO"
----

ご覧のとおり、異なる名前空間の変数や関数へのアクセスには、完全修飾名（namespace + var name）を使用しています。

これで他の名前空間にもアクセスできるようになりますが、繰り返しが多く、冗長になります。名前空間の名前が非常に長い場合は特に違和感があるでしょう。これを解決するには、 `:as` ディレクティブを使用して、名前空間への追加の（通常はより短い）エイリアスを作成することができます。 このようにすることができます。

[source, clojure]
----
(ns myapp.main
  (:require [myapp.core :as core]
            [clojure.string :as str]))

(str/upper-case core/x)
;; => "HELLO"
----

名前空間エイリアスの特徴として、特定の名前空間から名前空間キーワードを取得するのに使用できることが挙げられます。

[source, clojure]
----
(ns myapp.main
  (:require [myapp.core :as c]))

::c/foo
;; => :myapp.core/foo
----

同じように、マップの作成時にすべてのキーを名前空間化することもできます。

[source, clojure]
----
(def x #::c {:a 1})

x
;; => #:myapp.core{:a 1}

(::c/a x)
;; => 1
----


さらに、_ClojureScript_ では、`:refer` ディレクティブを使用して、具体的な名前空間から特定の変数や関数を参照する簡単な方法を提供しています。これに続いて、名前空間内の変数を参照する一連のシンボルを使用します。事実上、これらの変数や関数は自分の名前空間の一部であるかのようであり、それらを修飾する必要はありません。

[source, clojure]
----
(ns myapp.main
  (:require [clojure.string :refer [upper-case]]))
(upper-case x)
;; => "HELLO"
----

最後に、`cljs.core` 名前空間にあるものはすべて自動的にロードされるので、明示的に要求してはいけないことを知っておく必要があります。時には、`cljs.core` 名前空間で定義された他の変数と衝突するような変数を宣言したい場合があります。そのために、 `ns` マクロには、特定のシンボルを除外して自動的にロードされないようにするための別のディレクティブが用意されています。

次のようにします。

[source, clojure]
----
(ns myapp.main
  (:refer-clojure :exclude [min]))

(defn min
  [x y]
  (if (> x y)
    y
    x))
----

`ns` マクロには、ホストクラス（ `:import` ）やマクロ（ `:refer-macros` ）を読み込むための他のディレクティブもありますが、これらについては他のセクションで説明します。


==== Namespaces and File Names

`myapp.core` のような名前空間を持つ場合、コードは _myapp_ ディレクトリ内の _core.cljs_ という名前のファイルに記述しなければなりません。 つまり、名前空間 `myapp.core` と `myapp.main` を持つ前述の例は、次のようなファイル構造を持つプロジェクトで見つかります。

----
myapp
└── src
    └── myapp
        ├── core.cljs
        └── main.cljs
----


=== Abstractions and Polymorphism

I'm sure that at more than one time you have found yourself in this situation: you have defined a great abstraction (using interfaces or something similar) for your "business logic", and you have found the need to deal with another module over which you have absolutely no control, and you probably were thinking of creating adapters, proxies, and other approaches that imply a great amount of additional complexity.

Some dynamic languages allow "monkey-patching"; languages where the classes are open and any method can be defined and redefined at any time. Also, it is well known that this technique is a very bad practice.

We can not trust languages that allow you to silently overwrite methods that you are using when you import third party libraries; you cannot expect consistent behavior when this happens.

These symptoms are commonly called the "expression problem";
see http://en.wikipedia.org/wiki/Expression_problem for more details


==== Protocols

The _ClojureScript_ primitive for defining "interfaces" is called a protocol. A protocol consists of a name and set of functions. All the functions have at least one argument corresponding to the `this` in JavaScript or `self` in Python.

Protocols provide a type-based polymorphism, and the dispatch is always done by the first argument (equivalent to JavaScript’s `this`, as previously mentioned).

A protocol looks like this:

[source, clojure]
----
(ns myapp.testproto)

(defprotocol IProtocolName
  "A docstring describing the protocol."
  (sample-method [this] "A doc string associated with this function."))
----

NOTE: the "I" prefix is commonly used to designate the separation of protocols and types. In the Clojure community, there are many different opinions about how the "I" prefix should be used. In our opinion, it is an acceptable solution to avoid name clashing and possible confusion. But not using the prefix is not considered bad practice.

From the user perspective, protocol functions are simply plain functions defined in the namespace where the protocol is defined. This enables an easy and simple aproach for avoid conflicts between different protocols implemented for the same type that have conflicting function names.

Here is an example. Let's create a protocol called `IInvertible` for data that can be "inverted".  It will have a single method named `invert`.

[source, clojure]
----
(defprotocol IInvertible
  "This is a protocol for data types that are 'invertible'"
  (invert [this] "Invert the given item."))
----


===== Extending existing types

One of the big strengths of protocols is the ability to extend existing and maybe third party types. This operation can be done in different ways.

The majority of time you will tend to use the *extend-protocol* or the *extend-type* macros. This is how `extend-type` syntax looks:

[source, clojure]
----
(extend-type TypeA
  ProtocolA
  (function-from-protocol-a [this]
    ;; implementation here
    )

  ProtocolB
  (function-from-protocol-b-1 [this parameter1]
    ;; implementation here
    )
  (function-from-protocol-b-2 [this parameter1 parameter2]
    ;; implementation here
    ))
----

You can observe that with *extend-type* you are extending a single type with different protocols in a single expression.

Let's play with our `IInvertible` protocol defined previously:

[source, clojure]
----
(extend-type string
  IInvertible
  (invert [this] (apply str (reverse this))))

(extend-type cljs.core.List
  IInvertible
  (invert [this] (reverse this)))

(extend-type cljs.core.PersistentVector
  IInvertible
  (invert [this] (into [] (reverse this))))
----

You may note that a special symbol *string* is used instead of `js/String` for extend the protol for string. This is because the builtin javascript types have special treatment and if you replace the `string` with `js/String` the compiler will emit a warning about that.

So if you want extend your protocol to javascript primitive types, instead of using `js/Number`, `js/String`, `js/Object`, `js/Array`, `js/Boolean` and `js/Function` you should use the respective special symbols: `number`, `string`, `object`, `array`, `boolean` and `function`.

Now, it's time to try our protocol implementation:

[source, clojure]
----
(invert "abc")
;; => "cba"

(invert 0)
;; => 0

(invert '(1 2 3))
;; => (3 2 1)

(invert [1 2 3])
;; => [3 2 1]
----

In comparison, *extend-protocol* does the inverse; given a protocol, it adds implementations for multiple types. This is how the syntax looks:

[source, clojure]
----
(extend-protocol ProtocolA
  TypeA
  (function-from-protocol-a [this]
    ;; implementation here
    )

  TypeB
  (function-from-protocol-a [this]
    ;; implementation here
    ))
----

Thus, the previous example could have been written equally well with this way:

[source, clojure]
----
(extend-protocol IInvertible
  string
  (invert [this] (apply str (reverse this)))

  cljs.core.List
  (invert [this] (reverse this))

  cljs.core.PersistentVector
  (invert [this] (into [] (reverse this))))
----


===== Participate in ClojureScript abstractions

ClojureScript itself is built up on abstractions defined as protocols. Almost all behavior in the _ClojureScript_ language itself can be adapted to third party libraries. Let's look at a real life example.

In previous sections, we have explained the different kinds of built-in collections. For this example we will use a *set*. See this snippet of code:

[source, clojure]
----
(def mynums #{1 2})

(filter mynums [1 2 4 5 1 3 4 5])
;; => (1 2 1)
----

What happened? In this case, the _set_ type implements the _ClojureScript_ internal `IFn` protocol that represents an abstraction for functions or anything callable. This way it can be used like a callable predicate in filter.

OK, but what happens if we want to use a regular expression as a predicate function for filtering a collection of strings:

[source, clojure]
----
(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; TypeError: Cannot call undefined
----

The exception is raised because the `RegExp` type does not implement the `IFn` protocol so it cannot behave like a callable, but that can be easily fixed:

[source, clojure]
----
(extend-type js/RegExp
  IFn
  (-invoke
   ([this a]
     (re-find this a))))
----

Let’s analyze this: we are extending the `js/RegExp` type so that it implements the `invoke` function in the `IFn` protocol. To invoke a regular expression `a` as if it were a function, call the `re-find` function with the object of the function and the pattern.

Now, you will be able use the regex instances as predicates in a filter operation:

[source, clojure]
----
(filter #"^foo" ["haha" "foobar" "baz" "foobaz"])
;; => ("foobar" "foobaz")
----


===== Introspection using Protocols

_ClojureScript_ comes with a useful function that allows runtime introspection: `satisfies?`. The purpose of this function is to determine at runtime if some object (instance of some type) satisfies the concrete protocol.

So, with the previous examples, if we check if a `set` instance satisfies an *IFn*
protocol, it should return `true`:

[source, clojure]
----
(satisfies? IFn #{1})
;; => true
----


==== Multimethods

We have previously talked about protocols which solve a very common use case of polymorphism: dispatch by type. But in some circumstances, the protocol approach can be limiting. And here, *multimethods* come to the rescue.

These *multimethods* are not limited to type dispatch only; instead, they also offer dispatch by types of multiple arguments and by value. They also allow ad-hoc hierarchies to be defined. Also, like protocols, multimethods are an "Open System", so you or any third parties can extend a multimethod for new types.

The basic constructions of *multimethods* are the `defmulti` and `defmethod` forms. The `defmulti` form is used to create the multimethod with an initial dispatch function. This is a model of what it looks like:

[source, clojure]
----
(defmulti say-hello
  "A polymorphic function that return a greetings message
  depending on the language key with default lang as `:en`"
  (fn [param] (:locale param))
  :default :en)
----

The anonymous function defined within the `defmulti` form is a dispatch function. It will be called in every call to the `say-hello` function and should return some kind of marker object that will be used for dispatch. In our example, it returns the contents of the `:locale` key of the first argument.

And finally, you should add implementations. That is done with the `defmethod` form:

[source, clojure]
----
(defmethod say-hello :en
  [person]
  (str "Hello " (:name person "Anonymous")))

(defmethod say-hello :es
  [person]
  (str "Hola " (:name person "Anónimo")))
----

So, if you execute that function over a hash map containing the `:locale` and optionally the `:name` key, the multimethod will first call the dispatch function to determine the dispatch value, then it will search for an implementation for that value. If an implementation is found, the dispatcher will execute it. Otherwise, the dispatch will search for a default implementation (if one is specified) and execute it.

[source, clojure]
----
(say-hello {:locale :es})
;; => "Hola Anónimo"

(say-hello {:locale :en :name "Ciri"})
;; => "Hello Ciri"

(say-hello {:locale :fr})
;; => "Hello Anonymous"
----

If the default implementation is not specified, an exception will be raised notifying you that some value does not have an implementation for that multimethod.


==== Hierarchies

Hierarchies are _ClojureScript_’s way to let you build whatever relations that your domain may require. Hierarchies are defined in term of relations between named objects, such as symbols, keywords, or types.

Hierarchies can be defined globally or locally, depending on your needs. Like multimethods, hierarchies are not limited to a single namespace. You can extend a hierarchy from any namespace, not only from the one in which it is defined.

The global namespace is more limited, for good reasons. Keywords or symbols that are not namespaced can not be used in the global hierarchy. That behavior helps prevent unexpected situations when two or more third party libraries use the same symbol for different semantics.


===== Defining a hierarchy

The hierarchy relations should be established using the `derive` function:

[source, clojure]
----
(derive ::circle ::shape)
(derive ::box ::shape)
----

We have just defined a set of relationships between namespaced keywords. In this case the `::circle` is a child of `::shape`, and `::box` is also a child of `::shape`.

TIP: The `::circle` keyword syntax is a shorthand for `:current.ns/circle`. So if you are executing it in a REPL, `::circle` will be evaluated as `:cljs.user/circle`.


===== Hierarchies and introspection

_ClojureScript_ comes with a little toolset of functions that allows runtime introspection of globally or locally defined hierarchies. This toolset consists of three functions: `isa?`, `ancestors`, and `descendants`.

Let's see an example of how it can be used with the hierarchy defined in the previous example:

[source, clojure]
----
(ancestors ::box)
;; => #{:cljs.user/shape}

(descendants ::shape)
;; => #{:cljs.user/circle :cljs.user/box}

(isa? ::box ::shape)
;; => true

(isa? ::rect ::shape)
;; => false
----


===== Locally defined hierarchies

As we mentioned previously, in _ClojureScript_ you also can define local hierarchies. This can be done with the `make-hierarchy` function. Here is an example of how you can replicate the previous example using a local hierarchy:

[source, clojure]
----
(def h (-> (make-hierarchy)
           (derive :box :shape)
           (derive :circle :shape)))
----

Now you can use the same introspection functions with that locally defined hierarchy:

[source, clojure]
----
(isa? h :box :shape)
;; => true

(isa? :box :shape)
;; => false
----

As you can observe, in local hierarchies we can use normal (not namespace qualified) keywords, and if we execute the `isa?` without passing the local hierarchy parameter, it returns `false` as expected.


===== Hierarchies in multimethods

One of the big advantages of hierarchies is that they work very well together with multimethods.  This is because multimethods by default use the `isa?` function for the last step of dispatching.

Let's see an example to clearly understand what that means. First, we define the multimethod with the `defmulti` form:

[source, clojure]
----
(defmulti stringify-shape
  "A function that prints a human readable representation
  of a shape keyword."
  identity
  :hierarchy #'h)
----

With the `:hierarchy` keyword parameter, we indicate to the multimethod what hierarchy we want to use; if it is not specified, the global hierarchy will be used.

Second, we define an implementation for our multimethod using the `defmethod` form:

[source, clojure]
----
(defmethod stringify-shape :box
  [_]
  "A box shape")

(defmethod stringify-shape :shape
  [_]
  "A generic shape")

(defmethod stringify-shape :default
  [_]
  "Unexpected object")
----

Now, let's see what happens if we execute that function with a box:

[source, clojure]
----
(stringify-shape :box)
;; => "A box shape"
----

Now everything works as expected; the multimethod executes the direct matching implementation for the given parameter. Next, let's see what happens if we execute the same function but with the `:circle` keyword as the parameter which does not have the direct matching dispatch value:

[source, clojure]
----
(stringify-shape :circle)
;; => "A generic shape"
----

The multimethod automatically resolves it using the provided hierarchy, and since `:circle` is a descendant of `:shape`, the `:shape` implementation is executed.

Finally, if you give a keyword that isn't part of the hierarchy, you get the `:default` implementation:

[source,clojure]
----
(stringify-shape :triangle)
;; => "Unexpected object"
----


=== Data types

Until now, we have used maps, sets, lists, and vectors to represent our data. And in most cases, this is a really great approach. But sometimes we need to define our own types, and in this book we will call them *data types*.

A data type provides the following:

* A unique host-backed type, either named or anonymous.
* The ability to implement protocols (inline).
* Explicitly declared structure using fields or closures.
* Map-like behavior (via records, see below).


==== Deftype

The most low-level construction in _ClojureScript_ for creating your own types is the `deftype` macro. As a demonstration, we will define a type called `User`:

[source, clojure]
----
(deftype User [firstname lastname])
----

Once the type has been defined, we can create an instance of our `User`. In the following example, the `.` after `User` indicates that we are calling a constructor.

[source, clojure]
----
(def person (User. "Triss" "Merigold"))
----

Its fields can be accessed using the prefix dot notation:

[source, clojure]
----
(.-firstname person)
;; => "Triss"
----

Types defined with `deftype` (and `defrecord`, which we will see later) create a host-backed class-like object associated with the current namespace. For convenience, _ClojureScript_ also defines a constructor function called `->User` that can be imported using the `:require` directive.

We personally do not like this type of function, and we prefer to define our own constructors with more idiomatic names:

[source, clojure]
----
(defn make-user
  [firstname lastname]
  (User. firstname lastname))
----

We use this in our code instead of `->User`.


==== Defrecord

The record is a slightly higher-level abstraction for defining types in _ClojureScript_ and should be the preferred way to do it.

As we know, _ClojureScript_ tends to use plain data types such as maps, but in most cases we need a named type to represent the entities of our application. Here come the records.

A record is a data type that implements the map protocol and therefore can be used like any other map.  And since records are also proper types, they support type-based polymorphism through protocols.

In summary: with records, we have the best of both worlds, maps that can play in different abstractions.

Let's start defining the `User` type but using records:

[source, clojure]
----
(defrecord User [firstname lastname])
----

It looks really similar to the `deftype` syntax; in fact, it uses `deftype` behind the scenes as a low-level primitive for defining types.

Now, look at the difference with raw types for access to its fields:

[source, clojure]
----
(def person (User. "Yennefer" "of Vengerberg"))

(:firstname person)
;; => "Yennefer"

(get person :firstname)
;; => "Yennefer"
----

As we mentioned previously, records are maps and act like them:

[source, clojure]
----
(map? person)
;; => true
----

And like maps, they support extra fields that are not initially defined:

[source, clojure]
----
(def person2 (assoc person :age 92))

(:age person2)
;; => 92
----

As we can see, the `assoc` function works as expected and returns a new instance of the same type but with new key value pair. But take care with `dissoc`! Its behavior with records is slightly different than with maps; it will return a new record if the field being dissociated is an optional field, but it will return a plain map if you dissociate a mandatory field.

Another difference with maps is that records do not act like functions:

[source, clojure]
----
(def plain-person {:firstname "Yennefer", :lastname "of Vengerberg"})

(plain-person :firstname)
;; => "Yennefer"

(person :firstname)
;; => person.User does not implement IFn protocol.
----

For convenience, the `defrecord` macro, like `deftype`, exposes a `->User` function, as well as an additional `map->User` constructor function. We have the same opinion about that constructor as with `deftype` defined ones: we recommend defining your own instead of using the other ones. But as they exist, let’s see how they can be used:

[source, clojure]
----
(def cirilla (->User "Cirilla" "Fiona"))
(def yen (map->User {:firstname "Yennefer"
                     :lastname "of Vengerberg"}))
----


==== Implementing protocols

Both type definition primitives that we have seen so far allow inline implementations for protocols (explained in a previous section). Let's define one for example purposes:

[source, clojure]
----
(defprotocol IUser
  "A common abstraction for working with user types."
  (full-name [_] "Get the full name of the user."))
----

Now, you can define a type with inline implementation for an abstraction, in our case the `IUser`:

[source, clojure]
----
(defrecord User [firstname lastname]
  IUser
  (full-name [_]
    (str firstname " " lastname)))

;; Create an instance.
(def user (User. "Yennefer" "of Vengerberg"))

(full-name user)
;; => "Yennefer of Vengerberg"
----


==== Reify

The `reify` macro is an _ad hoc constructor_ you can use to create objects without pre-defining a type.  Protocol implementations are supplied the same as `deftype` and `defrecord`, but in contrast, `reify` does not have accessible fields.

This is how we can emulate an instance of the user type that plays well with the `IUser` abstraction:

[source, clojure]
----
(defn user
  [firstname lastname]
  (reify
    IUser
    (full-name [_]
      (str firstname " " lastname))))

(def yen (user "Yennefer" "of Vengerberg"))
(full-name yen)
;; => "Yennefer of Vengerberg"
----

==== Specify

`specify!` is an advanced alternative to `reify`, allowing you to add protocol implementations to an existing JavaScript object.  This can be useful if you want to graft protocols onto a JavaScript library's components.

[source, clojure]
----
(def obj #js {})

(specify! obj
  IUser
  (full-name [_]
    "my full name"))

(full-name obj)
;; => "my full name"
----

`specify` is an immutable version of `specify!` that can be used on immutable, copyable values implementing `ICloneable` (e.g. ClojureScript collections).

[source, clojure]
----
(def a {})

(def b (specify a
         IUser
         (full-name [_]
           "my full name")))

(full-name a)
;; Error: No protocol method IUser.full-name defined for type cljs.core/PersistentArrayMap: {}

(full-name b)
;; => "my full name"
----


=== Host interoperability

_ClojureScript_, in the same way as its brother Clojure, is designed to be a "guest" language. This means that the design of the language works well on top of an existing ecosystem such as JavaScript for _ClojureScript_ and the JVM for _Clojure_.


==== The types

_ClojureScript_, unlike what you might expect, tries to take advantage of every type that the platform provides. This is a (perhaps incomplete) list of things that _ClojureScript_ inherits and reuses from the underlying platform:

* _ClojureScript_ strings are JavaScript *Strings*.
* _ClojureScript_ numbers are JavaScript *Numbers*.
* _ClojureScript_ `nil` is a JavaScript *null*.
* _ClojureScript_ regular expressions are JavaScript `RegExp` instances.
* _ClojureScript_ is not interpreted; it is always compiled down to JavaScript.
* _ClojureScript_ allows easy call to platform APIs with the same semantics.
* _ClojureScript_ data types internally compile to objects in JavaScript.

On top of it, _ClojureScript_ builds its own abstractions and types that do not exist in the platform, such as Vectors, Maps, Sets, and others that are explained in preceding sections of this chapter.


==== Interacting with platform types

_ClojureScript_ comes with a little set of special forms that allows it to interact with platform types such as calling object methods, creating new instances, and accessing object properties.


===== Access to the platform

_ClojureScript_ has a special syntax for access to the entire platform environment through the `js/` special namespace. This is an example of an expression to execute JavaScript's built-in `parseInt` function:

[source, clojure]
----
(js/parseInt "222")
;; => 222
----


===== Creating new instances

_ClojureScript_ has two ways to create instances:

Using the `new` special form
[source, clojure]
----
(new js/RegExp "^foo$")
----

Using the `.` special form
[source, clojure]
----
(js/RegExp. "^foo$")
----

The last one is the recommended way to create instances. We are not aware of any real differences between the two forms, but in the ClojureScript community, the last one is used most often.


===== Invoke instance methods

To invoke methods of some object instance, as opposed to how it is done in JavaScript (e.g., `obj.method()`, the method name comes first like any other standard function in Lisp languages but with a little variation: the function name starts with special form `.`.

Let's see how we can call the `.test()` method of a regexp instance:

[source, clojure]
----
(def re (js/RegExp "^Clojure"))

(.test re "ClojureScript")
;; => true
----

You can invoke instance methods on JavaScript objects. The first example follows the pattern you have seen; the last one is a shortcut:

[source,clojure]
----
(.sqrt js/Math 2)
;; => 1.4142135623730951
(js/Math.sqrt 2)
;; => 1.4142135623730951
----


===== Access to object properties

Access to an object's properties is really very similar to calling a method. The difference is that instead of using the `.` you use `.-`. Let's see an example:

[source, clojure]
----
(.-multiline re)
;; => false
(.-PI js/Math)
;; => 3.141592653589793
----


===== Property access shorthand

Symbols with the `js/` prefix can contain dots to denote nested property access. Both of the following expressions invoke the same function:

[source, clojure]
----
(.log js/console "Hello World")

(js/console.log "Hello World")
----

And both of the following expressions access the same property:

[source, clojure]
----
(.-PI js/Math)
;; => 3.141592653589793

js/Math.PI
;; => 3.141592653589793
----


===== JavaScript objects

_ClojureScript_ has different ways to create plain JavaScript objects; each one has its own purpose. The basic one is the `js-obj` function. It accepts a variable number of pairs of keys and values and returns a JavaScript object:

[source, clojure]
----
(js-obj "country" "FR")
;; => #js {:country "FR"}
----

The return value can be passed to some kind of third party library that accepts a plain JavaScript object, but you can observe the real representation of the return value of this function. It is really another form for doing the same thing.

Using the reader macro `#js` consists of prepending it to a ClojureScript map or vector, and the result will be transformed to plain JavaScript:

[source, clojure]
----
(def myobj #js {:country "FR"})
----

The translation of that to plain JavaScript is similar to this:

[source, javascript]
----
var myobj = {country: "FR"};
----

As explained in the previous section, you can also access the plain object properties using the `.-` syntax:

[source, clojure]
----
(.-country myobj)
;; => "FR"
----

And as JavaScript objects are mutable, you can set a new value for some property using the `set!` function:

[source, clojure]
----
(set! (.-country myobj) "KR")
----


===== Conversions

The inconvenience of the previously explained forms is that they do not make recursive transformations, so if you have nested objects, the nested objects will not be converted.  Consider this example that uses Clojurescript maps, then a similar one with JavaScript objects:

[source, clojure]
----
(def clj-map {:country {:code "FR" :name "France"}})
;; => {:country {:code "FR", :name "France"}}
(:code (:country clj-map))
;; => "FR"

(def js-obj #js {:country {:code "FR" :name "France"}})
;; => #js {:country {:code "FR", :name "France"}
(.-country js-obj)
;; => {:code "FR", :name "France"}
(.-code (.-country js-obj)
;; => nil
----

To solve that use case, _ClojureScript_ comes with the `clj->js` and `js->clj` functions that transform Clojure collection types into JavaScript and back. Note that the conversion to ClojureScript changes the `:country` keyword to a string.

[source, clojure]
----
(clj->js {:foo {:bar "baz"}})
;; => #js {:foo #js {:bar "baz"}}
(js->clj #js {:country {:code "FR" :name "France"}}))
;; => {"country" {:code "FR", :name "France"}}
----

In the case of arrays, there is a specialized function `into-array` that behaves as expected:

[source, clojure]
----
(into-array ["France" "Korea" "Peru"])
;; => #js ["France" "Korea" "Peru"]
----


===== Arrays

In the previous example, we saw how we can create an array from an existing _ClojureScript_ collection. But there is another function for creating arrays: `make-array`.

.Creating a preallocated array with length 10
[source, clojure]
----
(def a (make-array 10))
;; => #js [nil nil nil nil nil nil nil nil nil nil]
----

In _ClojureScript_, arrays also play well with sequence abstractions, so you can iterate over them or simply get the number of elements with the `count` function:

[source, clojure]
----
(count a)
;; => 10
----

As arrays in the JavaScript platform are a mutable collection type, you can access a concrete index and set the value at that position:

[source, clojure]
----
(aset a 0 2)
;; => 2
a
;; => #js [2 nil nil nil nil nil nil nil nil nil]
----

Or access in an indexed way to get its values:

[source, clojure]
----
(aget a 0)
;; => 2
----

In JavaScript, array index access is equivalent to object property access, so you can use the same functions for interacting with plain objects:

[source, clojure]
----
(def b #js {:hour 16})
;; => #js {:hour 16}

(aget b "hour")
;; => 16

(aset b "minute" 22)
;; => 22

b
;; => #js {:hour 16, :minute 22}
----


=== State management

We've learned that one of ClojureScript's fundamental ideas is immutability. Both scalar values and collections are immutable in ClojureScript, except those mutable types present in the JS host like `Date`.

Immutability has many great properties but we are sometimes faced with the need to model values that change over time. How can we achieve this if we can't change data structures in place?


==== Vars

Vars can be redefined at will inside a namespace but there is no way to know *when* they change. The inability to redefine vars from other namespaces is a bit limiting; also, if we are modifying state, we're probably interested in knowing when it occurs.


==== Atoms

ClojureScript gives us the `Atom` type, which is an object containing a value that can be altered at will. Besides altering its value, it also supports observation through watcher functions that can be attached and detached from it and validation for ensuring that the value contained in the atom is always valid.

If we were to model an identity corresponding to a person called Ciri, we could wrap an immutable value containing Ciri's data in an atom. Note that we can get the atom's value with the `deref` function or using its shorthand `@` notation:

[source, clojure]
----
(def ciri (atom {:name "Cirilla" :lastname "Fiona" :age 20}))
;; #<Atom: {:name "Cirilla", :lastname "Fiona", :age 20}>

(deref ciri)
;; {:name "Cirilla", :lastname "Fiona", :age 20}

@ciri
;; {:name "Cirilla", :lastname "Fiona", :age 20}
----

We can use the `swap!` function on an atom to alter its value with a function. Since Ciri's birthday is today, let's increment her age count:

[source, clojure]
----
(swap! ciri update :age inc)
;; {:name "Cirilla", :lastname "Fiona", :age 21}

@ciri
;; {:name "Cirilla", :lastname "Fiona", :age 21}
----

The `reset!` functions replaces the value contained in the atom with a new one:

[source, clojure]
----
(reset! ciri {:name "Cirilla", :lastname "Fiona", :age 22})
;; {:name "Cirilla", :lastname "Fiona", :age 22}

@ciri
;; {:name "Cirilla", :lastname "Fiona", :age 22}
----

===== Observation

We can add and remove watcher functions for atoms. Whenever the atom's value is changed through a `swap!` or `reset!`, all the atom's watcher functions will be called. Watchers are added with the `add-watch` function. Notice that each watcher has a key associated (`:logger` in the example) to it which is later used to remove the watch from the atom.

[source, clojure]
----
(def a (atom))

(add-watch a :logger (fn [key the-atom old-value new-value]
                       (println "Key:" key "Old:" old-value "New:" new-value)))

(reset! a 42)
;; Key: :logger Old: nil New: 42
;; => 42

(swap! a inc)
;; Key: :logger Old: 42 New: 43
;; => 43

(remove-watch a :logger)
----


==== Volatiles

Volatiles, like atoms, are objects containing a value that can be altered. However, they don't provide the observation and validation capabilities that atoms provide. This makes them slightly more performant and a more suitable mutable container to use inside stateful functions that don't need observation nor validation.

Their API closely resembles that of atoms. They can be dereferenced to grab the value they contain and support swapping and resetting with `vswap!` and `vreset!` respectively:

[source, clojure]
----
(def ciri (volatile! {:name "Cirilla" :lastname "Fiona" :age 20}))
;; #<Volatile: {:name "Cirilla", :lastname "Fiona", :age 20}>

(volatile? ciri)
;; => true

(deref ciri)
;; {:name "Cirilla", :lastname "Fiona", :age 20}

(vswap! ciri update :age inc)
;; {:name "Cirilla", :lastname "Fiona", :age 21}

(vreset! ciri {:name "Cirilla", :lastname "Fiona", :age 22})
;; {:name "Cirilla", :lastname "Fiona", :age 22}
----

Note that another difference with atoms is that the constructor of volatiles uses a bang at the end. You create volatiles with `volatile!` and atoms with `atom`.
